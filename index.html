<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Needlepoint Designer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body, #root { height: 100%; width: 100%; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #fafafa; overflow: hidden; touch-action: none; }
    .grid-cell { transition: none; }
    input[type="range"] { -webkit-appearance: none; background: #e5e5e5; height: 8px; border-radius: 4px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 24px; height: 24px; background: #f59e0b; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    input[type="number"]::-webkit-inner-spin-button { opacity: 1; }
    .crop-handle { position: absolute; background: #f59e0b; border: 2px solid white; border-radius: 4px; }
    .bottom-sheet { transition: transform 0.3s ease-out; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    const { useState, useRef, useCallback, useEffect } = React;

    const PALETTE = {
      'Red': { hex: '#ed2415' },
      'Orange': { hex: '#ff9a03' },
      'Yellow': { hex: '#fcfc03' },
      'LimeGreen': { hex: '#1cfc03' },
      'DarkGreen': { hex: '#2ca11f' },
      'Brown': { hex: '#a66f17' },
      'Cream': { hex: '#e0af60' },
      'Black': { hex: '#000000' },
      'White': { hex: '#ffffff' },
      'Blue': { hex: '#2b98e0' },
      'DarkBlue': { hex: '#153dbf' },
      'Pink': { hex: '#db9ad5' },
      'Gray': { hex: '#969696' },
    };

    const PALETTE_ORDER = ['White', 'Black', 'Gray', 'Red', 'Orange', 'Yellow', 'LimeGreen', 'DarkGreen', 'Blue', 'DarkBlue', 'Pink', 'Brown', 'Cream'];
    const MAX_CROSSES = { 13: 110, 15: 127 };
    const MAX_COLORS = 8; // Maximum colors including white

    function App() {
      const [designName, setDesignName] = useState('MyDesign');
      const [canvasCount, setCanvasCount] = useState(13);
      const [grid, setGrid] = useState(null);
      const [selectedColor, setSelectedColor] = useState('Black');
      const [gridWidth, setGridWidth] = useState('26');
      const [gridHeight, setGridHeight] = useState('26');
      const [canvasOpacity, setCanvasOpacity] = useState(0.5);
      const [showCanvas, setShowCanvas] = useState(true);
      const [refImage, setRefImage] = useState(null);
      const [refImageSize, setRefImageSize] = useState({ width: 300, height: 300 });
      const [refImagePosition, setRefImagePosition] = useState({ x: 20, y: 20 });
      const [refImageLocked, setRefImageLocked] = useState(false);
      const [showRefImage, setShowRefImage] = useState(true);
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);
      const [isPainting, setIsPainting] = useState(false);
      const [isDraggingImage, setIsDraggingImage] = useState(false);
      const [isResizingImage, setIsResizingImage] = useState(false);
      const [brushSize, setBrushSize] = useState(1);
      const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
      const [showBrushCursor, setShowBrushCursor] = useState(false);
      
      // Mobile panels
      const [activePanel, setActivePanel] = useState(null); // 'settings', 'colors', 'reference'
      const [showMobileMenu, setShowMobileMenu] = useState(false);
      const [isMobile, setIsMobile] = useState(window.innerWidth < 769);
      const [showDownloadMenu, setShowDownloadMenu] = useState(false);
      
      // Saved designs
      const [showSavedMenu, setShowSavedMenu] = useState(false);
      const [savedDesigns, setSavedDesigns] = useState([]);
      const [showColorWarning, setShowColorWarning] = useState(false);
      
      // Unsaved changes tracking
      const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
      const [lastSavedState, setLastSavedState] = useState(null);
      
      // Image positioning mode
      const [isPositioningImage, setIsPositioningImage] = useState(false);
      
      // Update isMobile on resize
      useEffect(() => {
        const handleResize = () => setIsMobile(window.innerWidth < 769);
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);
      
      // Track unsaved changes
      useEffect(() => {
        if (grid && lastSavedState !== JSON.stringify(grid)) {
          setHasUnsavedChanges(true);
        }
      }, [grid, lastSavedState]);
      
      // Warn before closing with unsaved changes
      useEffect(() => {
        const handleBeforeUnload = (e) => {
          if (hasUnsavedChanges && grid) {
            e.preventDefault();
            e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
            return e.returnValue;
          }
        };
        window.addEventListener('beforeunload', handleBeforeUnload);
        return () => window.removeEventListener('beforeunload', handleBeforeUnload);
      }, [hasUnsavedChanges, grid]);
      
      // Cropping state
      const [isCropping, setIsCropping] = useState(false);
      const [cropBox, setCropBox] = useState({ x: 0, y: 0, w: 100, h: 100 });
      const [isDraggingCrop, setIsDraggingCrop] = useState(false);
      const [cropDragType, setCropDragType] = useState(null);
      const [originalImageData, setOriginalImageData] = useState(null);
      
      // Pan and Zoom
      const [zoom, setZoom] = useState(1);
      const [pan, setPan] = useState({ x: 0, y: 0 });
      const [isPanning, setIsPanning] = useState(false);
      const [gridOffset, setGridOffset] = useState({ x: 0, y: 0 });
      const [panOnly, setPanOnly] = useState(false); // When true, disables painting
      
      // Touch state
      const [touchMode, setTouchMode] = useState(null); // 'paint', 'pan', 'pinch'
      const lastTouchRef = useRef(null);

      const refImageInputRef = useRef(null);
      const workspaceRef = useRef(null);
      const contentRef = useRef(null);
      const gridRef = useRef(null);
      const panStartRef = useRef({ x: 0, y: 0, panX: 0, panY: 0 });
      const imgDragStartRef = useRef({ x: 0, y: 0, imgX: 0, imgY: 0 });
      const imgResizeStartRef = useRef({ w: 0, h: 0, x: 0, y: 0 });
      const pinchStartRef = useRef({ distance: 0, zoom: 1, panX: 0, panY: 0, centerX: 0, centerY: 0 });
      const cropStartRef = useRef({ x: 0, y: 0, box: null });
      const touchStartTimeRef = useRef(null);
      const pendingPaintRef = useRef(null);

      const cellSize = 18;
      const crossesPerInch = canvasCount;
      const maxCrosses = MAX_CROSSES[canvasCount];
      const parsedWidth = gridWidth === '' ? 0 : parseInt(gridWidth) || 0;
      const parsedHeight = gridHeight === '' ? 0 : parseInt(gridHeight) || 0;

      const getUsedColors = useCallback(() => {
        if (!grid) return {};
        const counts = {};
        grid.forEach(row => row.forEach(color => {
          counts[color] = (counts[color] || 0) + 1;
        }));
        return counts;
      }, [grid]);

      const usedColors = getUsedColors();
      const colorCount = Object.keys(usedColors).filter(c => usedColors[c] > 0).length;
      
      // Check for color warning when color count changes
      useEffect(() => {
        if (colorCount > MAX_COLORS) {
          setShowColorWarning(true);
        }
      }, [colorCount]);

      // Load saved designs from localStorage on mount
      useEffect(() => {
        const saved = localStorage.getItem('needlepoint_designs');
        if (saved) {
          try {
            setSavedDesigns(JSON.parse(saved));
          } catch (e) {
            console.error('Error loading saved designs:', e);
          }
        }
      }, []);

      // Save design to localStorage
      const saveDesign = () => {
        if (!grid) return;
        const design = {
          id: Date.now(),
          name: designName,
          canvasCount,
          grid,
          gridWidth: grid[0].length,
          gridHeight: grid.length,
          refImage,
          refImageSize,
          refImagePosition,
          savedAt: new Date().toISOString()
        };
        const updated = [...savedDesigns.filter(d => d.name !== designName), design];
        setSavedDesigns(updated);
        localStorage.setItem('needlepoint_designs', JSON.stringify(updated));
        setLastSavedState(JSON.stringify(grid));
        setHasUnsavedChanges(false);
        alert('Design saved!');
      };

      // Load design from localStorage
      const loadDesign = (design) => {
        setDesignName(design.name);
        setCanvasCount(design.canvasCount);
        setGrid(design.grid);
        setGridWidth(String(design.gridWidth));
        setGridHeight(String(design.gridHeight));
        if (design.refImage) {
          setRefImage(design.refImage);
          setRefImageSize(design.refImageSize);
          setRefImagePosition(design.refImagePosition);
        }
        setHistory([]);
        setHistoryIndex(-1);
        setShowSavedMenu(false);
      };

      // Delete saved design
      const deleteDesign = (id) => {
        const updated = savedDesigns.filter(d => d.id !== id);
        setSavedDesigns(updated);
        localStorage.setItem('needlepoint_designs', JSON.stringify(updated));
      };

      const saveHistory = useCallback((newGrid) => {
        setHistory(prev => {
          const h = prev.slice(0, historyIndex + 1);
          h.push(JSON.stringify(newGrid));
          return h.slice(-50);
        });
        setHistoryIndex(prev => Math.min(prev + 1, 49));
      }, [historyIndex]);

      const createGrid = () => {
        const w = Math.min(parsedWidth, maxCrosses);
        const h = Math.min(parsedHeight, maxCrosses);
        if (w < 1 || h < 1) return;
        const newGrid = Array(h).fill(null).map(() => Array(w).fill('White'));
        setGrid(newGrid);
        setHistory([JSON.stringify(newGrid)]);
        setHistoryIndex(0);
        setPan({ x: 0, y: 0 });
        setZoom(1);
        setGridOffset({ x: 0, y: 0 });
        setActivePanel(null);
      };

      const undo = () => {
        if (historyIndex > 0) {
          setHistoryIndex(historyIndex - 1);
          setGrid(JSON.parse(history[historyIndex - 1]));
        }
      };

      const redo = () => {
        if (historyIndex < history.length - 1) {
          setHistoryIndex(historyIndex + 1);
          setGrid(JSON.parse(history[historyIndex + 1]));
        }
      };

      const addRowTop = () => {
        if (!grid || grid.length >= maxCrosses) return;
        const newRow = Array(grid[0].length).fill('White');
        const newGrid = [newRow, ...grid];
        setGrid(newGrid);
        setGridHeight(String(newGrid.length));
        setGridOffset(o => ({ x: o.x, y: o.y - cellSize }));
        saveHistory(newGrid);
      };

      const addRowBottom = () => {
        if (!grid || grid.length >= maxCrosses) return;
        const newRow = Array(grid[0].length).fill('White');
        const newGrid = [...grid, newRow];
        setGrid(newGrid);
        setGridHeight(String(newGrid.length));
        saveHistory(newGrid);
      };

      const removeRowTop = () => {
        if (!grid || grid.length <= 1) return;
        const newGrid = grid.slice(1);
        setGrid(newGrid);
        setGridHeight(String(newGrid.length));
        setGridOffset(o => ({ x: o.x, y: o.y + cellSize }));
        saveHistory(newGrid);
      };

      const removeRowBottom = () => {
        if (!grid || grid.length <= 1) return;
        const newGrid = grid.slice(0, -1);
        setGrid(newGrid);
        setGridHeight(String(newGrid.length));
        saveHistory(newGrid);
      };

      const addColLeft = () => {
        if (!grid || grid[0].length >= maxCrosses) return;
        const newGrid = grid.map(row => ['White', ...row]);
        setGrid(newGrid);
        setGridWidth(String(newGrid[0].length));
        setGridOffset(o => ({ x: o.x - cellSize, y: o.y }));
        saveHistory(newGrid);
      };

      const addColRight = () => {
        if (!grid || grid[0].length >= maxCrosses) return;
        const newGrid = grid.map(row => [...row, 'White']);
        setGrid(newGrid);
        setGridWidth(String(newGrid[0].length));
        saveHistory(newGrid);
      };

      const removeColLeft = () => {
        if (!grid || grid[0].length <= 1) return;
        const newGrid = grid.map(row => row.slice(1));
        setGrid(newGrid);
        setGridWidth(String(newGrid[0].length));
        setGridOffset(o => ({ x: o.x + cellSize, y: o.y }));
        saveHistory(newGrid);
      };

      const removeColRight = () => {
        if (!grid || grid[0].length <= 1) return;
        const newGrid = grid.map(row => row.slice(0, -1));
        setGrid(newGrid);
        setGridWidth(String(newGrid[0].length));
        saveHistory(newGrid);
      };

      const paintWithBrush = useCallback((centerX, centerY) => {
        if (!grid) return;
        const radius = brushSize - 1;
        const newGrid = grid.map((row, y) => 
          row.map((cell, x) => {
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance <= radius + 0.5) {
              return selectedColor;
            }
            return cell;
          })
        );
        setGrid(newGrid);
      }, [grid, brushSize, selectedColor]);

      const fillRegion = (startX, startY) => {
        if (!grid) return;
        const target = grid[startY][startX];
        if (target === selectedColor) return;
        const newGrid = grid.map(r => [...r]);
        const stack = [[startX, startY]];
        const visited = new Set();
        while (stack.length) {
          const [x, y] = stack.pop();
          const key = x + ',' + y;
          if (visited.has(key) || x < 0 || x >= grid[0].length || y < 0 || y >= grid.length) continue;
          if (newGrid[y][x] !== target) continue;
          visited.add(key);
          newGrid[y][x] = selectedColor;
          stack.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
        }
        setGrid(newGrid);
        saveHistory(newGrid);
      };

      const handleRefUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const img = new Image();
          img.onload = () => {
            // Auto-create grid if not exists
            if (!grid) {
              const w = Math.min(parseInt(gridWidth) || 26, maxCrosses);
              const h = Math.min(parseInt(gridHeight) || 26, maxCrosses);
              if (w >= 1 && h >= 1) {
                const newGrid = Array(h).fill(null).map(() => Array(w).fill('White'));
                setGrid(newGrid);
                saveHistory(newGrid);
              }
            }
            
            const scale = Math.min(300 / img.width, 300 / img.height, 1);
            setRefImageSize({ width: img.width * scale, height: img.height * scale });
            setRefImage(ev.target.result);
            setOriginalImageData(ev.target.result);
            setRefImagePosition({ x: 50, y: 50 });
            setCropBox({ x: 0, y: 0, w: img.width * scale, h: img.height * scale });
            setShowRefImage(true);
            setIsPositioningImage(true); // Enter positioning mode
            setActivePanel(null); // Close any open panel
          };
          img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      };

      const finishPositioning = () => {
        setIsPositioningImage(false);
        setIsDraggingImage(false);
        setIsResizingImage(false);
      };

      const startCropping = () => {
        setIsCropping(true);
        setCropBox({ x: 0, y: 0, w: refImageSize.width, h: refImageSize.height });
        setActivePanel(null);
      };

      const applyCrop = () => {
        if (!originalImageData) return;
        const img = new Image();
        img.onload = () => {
          const scaleX = img.width / refImageSize.width;
          const scaleY = img.height / refImageSize.height;
          const canvas = document.createElement('canvas');
          canvas.width = cropBox.w * scaleX;
          canvas.height = cropBox.h * scaleY;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, cropBox.x * scaleX, cropBox.y * scaleY, cropBox.w * scaleX, cropBox.h * scaleY, 0, 0, canvas.width, canvas.height);
          const croppedData = canvas.toDataURL('image/png');
          setRefImage(croppedData);
          setOriginalImageData(croppedData);
          setRefImageSize({ width: cropBox.w, height: cropBox.h });
          setIsCropping(false);
        };
        img.src = originalImageData;
      };

      const cancelCrop = () => {
        setIsCropping(false);
      };

      // DMC color mapping for our palette
      const DMC_COLORS = {
        'Black': { dmc: '310', name: 'Black' },
        'White': { dmc: '3865', name: 'White' },
        'Red': { dmc: '666', name: 'Red' },
        'Yellow': { dmc: '973', name: 'Yellow' },
        'Blue': { dmc: '826', name: 'Blue' },
        'DarkBlue': { dmc: '796', name: 'Royal Blue Dark' },
        'Pink': { dmc: '603', name: 'Pink' },
        'Brown': { dmc: '975', name: 'Brown' },
        'Cream': { dmc: '945', name: 'Cream (Tawny Brown)' },
        'LimeGreen': { dmc: '470', name: 'Light Avocado Green' },
        'DarkGreen': { dmc: '910', name: 'Dark Emerald Green' },
        'Gray': { dmc: '168', name: 'Light Pewter Gray' },
        'Orange': { dmc: '740', name: 'Tangerine' },
      };

      // Symbol mapping for pattern
      const SYMBOLS = ['●', '■', '▲', '◆', '★', '○', '□', '△', '◇', '☆', '✦', '✧', '⬟'];

      const exportJSON = () => {
        if (!grid) return;
        const data = {
          version: "2.1",
          design_name: designName,
          canvas_count: canvasCount,
          crosses_per_inch: crossesPerInch,
          design_width_crosses: grid[0].length,
          design_height_crosses: grid.length,
          design_width_inches: (grid[0].length / crossesPerInch).toFixed(2),
          design_height_inches: (grid.length / crossesPerInch).toFixed(2),
          colors_used: Object.keys(usedColors).filter(c => usedColors[c] > 0),
          color_counts: usedColors,
          palette: PALETTE,
          grid: grid,
          created_at: new Date().toISOString(),
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = designName + '_needlepoint.json';
        a.click();
        URL.revokeObjectURL(url);
        setShowDownloadMenu(false);
      };

      // Calculate thread length: 3.25 crosses per inch, +15% margin
      const calculateThreadLength = (stitchCount) => {
        const inchesPerCross = 1 / 3.25;
        const totalInches = stitchCount * inchesPerCross;
        const withMargin = totalInches * 1.15;
        const meters = withMargin * 0.0254;
        return meters.toFixed(1);
      };

      const generateStitchGuidePDF = async () => {
        if (!grid) return;
        
        // Load jsPDF from CDN
        if (!window.jspdf) {
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
          document.head.appendChild(script);
          await new Promise(resolve => script.onload = resolve);
        }
        
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('p', 'mm', 'a4');
        const pageWidth = 210;
        const pageHeight = 297;
        const bgColor = [173, 216, 230]; // Light blue (#ADD8E6)
        const textRed = [237, 36, 21]; // Red color from logo
        const margin = 15;
        
        // Get used colors
        const colorsUsed = Object.entries(usedColors).filter(([_, count]) => count > 0);
        const colorSymbols = {};
        colorsUsed.forEach(([color], i) => {
          colorSymbols[color] = SYMBOLS[i % SYMBOLS.length];
        });
        
        // Helper to add blue background
        const addBlueBg = () => {
          doc.setFillColor(...bgColor);
          doc.rect(0, 0, pageWidth, pageHeight, 'F');
        };
        
        // Helper to add footer logo text
        const addFooterLogo = () => {
          doc.setFontSize(14);
          doc.setTextColor(...textRed);
          doc.setFont('times', 'italic');
          doc.text('Love, Chloe', pageWidth / 2, pageHeight - 20, { align: 'center' });
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          doc.text('NEEDLEPOINT', pageWidth / 2, pageHeight - 14, { align: 'center' });
        };
        
        // ============ PAGE 1: Cover Page ============
        addBlueBg();
        
        // Title
        doc.setFontSize(36);
        doc.setTextColor(...textRed);
        doc.setFont('times', 'italic');
        doc.text('Love, Chloe', pageWidth / 2, 40, { align: 'center' });
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(14);
        doc.text('NEEDLEPOINT', pageWidth / 2, 50, { align: 'center' });
        doc.setFontSize(12);
        doc.text('Custom Stitch Guide', pageWidth / 2, 58, { align: 'center' });
        
        // Design preview (simple colored grid)
        const previewSize = 100;
        const previewX = (pageWidth - previewSize) / 2;
        const previewY = 75;
        const cellW = previewSize / grid[0].length;
        const cellH = previewSize / grid.length;
        
        // White border/frame
        doc.setFillColor(255, 255, 255);
        doc.rect(previewX - 5, previewY - 5, previewSize + 10, previewSize + 10, 'F');
        doc.setDrawColor(200, 200, 200);
        doc.rect(previewX - 5, previewY - 5, previewSize + 10, previewSize + 10, 'S');
        
        // Draw grid preview
        grid.forEach((row, y) => {
          row.forEach((color, x) => {
            const hex = PALETTE[color]?.hex || '#ffffff';
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            doc.setFillColor(r, g, b);
            doc.rect(previewX + x * cellW, previewY + y * cellH, cellW, cellH, 'F');
          });
        });
        
        // Design name
        doc.setFontSize(16);
        doc.setTextColor(50, 50, 50);
        doc.text(`"${designName}"`, pageWidth / 2, previewY + previewSize + 15, { align: 'center' });
        
        // Size info
        doc.setFontSize(11);
        doc.text(`${grid[0].length} × ${grid.length} stitches`, pageWidth / 2, previewY + previewSize + 23, { align: 'center' });
        doc.text(`${(grid[0].length / crossesPerInch).toFixed(2)}" × ${(grid.length / crossesPerInch).toFixed(2)}"`, pageWidth / 2, previewY + previewSize + 30, { align: 'center' });
        
        // Copyright
        doc.setFontSize(8);
        doc.setTextColor(80, 80, 80);
        const copyrightY = pageHeight - 35;
        doc.text('© Love, Chloe', pageWidth / 2, copyrightY, { align: 'center' });
        doc.text('Cross stitch and needlepoint patterns are for personal use only.', pageWidth / 2, copyrightY + 5, { align: 'center' });
        doc.text('Do not use or sell for commercial intent, redistribute, sell, or share in any manner.', pageWidth / 2, copyrightY + 10, { align: 'center' });
        
        // ============ PAGE 2: Color Pattern with Grid Numbers ============
        doc.addPage();
        addBlueBg();
        
        // Title
        doc.setFontSize(14);
        doc.setTextColor(...textRed);
        doc.text(designName, pageWidth / 2, 15, { align: 'center' });
        
        // Calculate grid dimensions for page
        const gridAreaWidth = pageWidth - margin * 2 - 20; // Leave room for numbers
        const gridAreaHeight = pageHeight - 60; // Leave room for header/footer
        const patternCellW = Math.min(gridAreaWidth / grid[0].length, 3);
        const patternCellH = Math.min(gridAreaHeight / grid.length, 3);
        const patternW = grid[0].length * patternCellW;
        const patternH = grid.length * patternCellH;
        const patternX = (pageWidth - patternW) / 2;
        const patternY = 30;
        
        // Draw grid numbers
        doc.setFontSize(5);
        doc.setTextColor(100, 100, 100);
        for (let i = 0; i <= grid[0].length; i += 10) {
          doc.text(String(i), patternX + i * patternCellW, patternY - 3, { align: 'center' });
        }
        for (let i = 0; i <= grid.length; i += 10) {
          doc.text(String(i), patternX - 5, patternY + i * patternCellH + 1);
        }
        
        // Draw colored pattern
        grid.forEach((row, y) => {
          row.forEach((color, x) => {
            const hex = PALETTE[color]?.hex || '#ffffff';
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            doc.setFillColor(r, g, b);
            doc.rect(patternX + x * patternCellW, patternY + y * patternCellH, patternCellW, patternCellH, 'F');
          });
        });
        
        // Grid lines
        doc.setDrawColor(150, 150, 150);
        doc.setLineWidth(0.1);
        for (let x = 0; x <= grid[0].length; x++) {
          doc.line(patternX + x * patternCellW, patternY, patternX + x * patternCellW, patternY + patternH);
        }
        for (let y = 0; y <= grid.length; y++) {
          doc.line(patternX, patternY + y * patternCellH, patternX + patternW, patternY + y * patternCellH);
        }
        
        addFooterLogo();
        
        // ============ PAGE 3: Black & White Symbol Pattern ============
        doc.addPage();
        addBlueBg();
        
        doc.setFontSize(14);
        doc.setTextColor(...textRed);
        doc.text(designName + ' - Symbol Chart', pageWidth / 2, 15, { align: 'center' });
        
        // Draw B&W pattern with symbols
        doc.setFontSize(patternCellW * 0.8);
        grid.forEach((row, y) => {
          row.forEach((color, x) => {
            // White background for each cell
            doc.setFillColor(255, 255, 255);
            doc.rect(patternX + x * patternCellW, patternY + y * patternCellH, patternCellW, patternCellH, 'F');
            
            // Draw symbol
            const symbol = colorSymbols[color] || '?';
            doc.setTextColor(0, 0, 0);
            doc.text(symbol, patternX + x * patternCellW + patternCellW / 2, patternY + y * patternCellH + patternCellH * 0.75, { align: 'center' });
          });
        });
        
        // Grid lines
        doc.setDrawColor(200, 200, 200);
        for (let x = 0; x <= grid[0].length; x++) {
          doc.line(patternX + x * patternCellW, patternY, patternX + x * patternCellW, patternY + patternH);
        }
        for (let y = 0; y <= grid.length; y++) {
          doc.line(patternX, patternY + y * patternCellH, patternX + patternW, patternY + y * patternCellH);
        }
        
        addFooterLogo();
        
        // ============ PAGE 4: Instructions & Symbol Key ============
        doc.addPage();
        addBlueBg();
        
        doc.setFontSize(16);
        doc.setTextColor(...textRed);
        doc.text('Instructions and Symbol Key', pageWidth / 2, 20, { align: 'center' });
        doc.setDrawColor(...textRed);
        doc.line(margin, 25, pageWidth - margin, 25);
        
        // Design info
        doc.setFontSize(11);
        doc.setTextColor(50, 50, 50);
        let infoY = 40;
        doc.text(`Fabric: ${canvasCount} count canvas`, margin, infoY);
        infoY += 8;
        doc.text(`Stitches: ${grid[0].length} × ${grid.length}`, margin, infoY);
        doc.text(`Size: ${(grid[0].length / crossesPerInch).toFixed(2)} × ${(grid.length / crossesPerInch).toFixed(2)} inches or ${(grid[0].length / crossesPerInch * 25.4).toFixed(1)} × ${(grid.length / crossesPerInch * 25.4).toFixed(1)} mm`, margin + 60, infoY);
        infoY += 8;
        doc.text('Colours: DMC', margin, infoY);
        infoY += 12;
        doc.text('Use 2 strands of thread for cross stitch', margin, infoY);
        
        // Symbol key table
        infoY += 15;
        doc.setFontSize(10);
        doc.setFont('helvetica', 'bold');
        doc.text('Sym', margin, infoY);
        doc.text('No.', margin + 20, infoY);
        doc.text('Colour Name', margin + 40, infoY);
        doc.text('Stitches', margin + 100, infoY);
        doc.setFont('helvetica', 'normal');
        
        infoY += 5;
        doc.line(margin, infoY, pageWidth - margin, infoY);
        infoY += 8;
        
        colorsUsed.forEach(([color, count]) => {
          const dmc = DMC_COLORS[color] || { dmc: '---', name: color };
          const symbol = colorSymbols[color];
          
          // Symbol with color background
          const hex = PALETTE[color]?.hex || '#ffffff';
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          doc.setFillColor(r, g, b);
          doc.rect(margin, infoY - 4, 8, 6, 'F');
          doc.setTextColor(r < 128 && g < 128 && b < 128 ? 255 : 0, r < 128 && g < 128 && b < 128 ? 255 : 0, r < 128 && g < 128 && b < 128 ? 255 : 0);
          doc.text(symbol, margin + 4, infoY, { align: 'center' });
          
          doc.setTextColor(50, 50, 50);
          doc.text(dmc.dmc, margin + 20, infoY);
          doc.text(dmc.name, margin + 40, infoY);
          doc.text(String(count), margin + 100, infoY);
          
          infoY += 8;
          if (infoY > pageHeight - 50) {
            doc.addPage();
            addBlueBg();
            infoY = 30;
          }
        });
        
        addFooterLogo();
        
        // ============ PAGE 5: Thread Length Estimate ============
        doc.addPage();
        addBlueBg();
        
        doc.setFontSize(16);
        doc.setTextColor(...textRed);
        doc.text('Thread Length Estimate', pageWidth / 2, 20, { align: 'center' });
        doc.setDrawColor(...textRed);
        doc.line(margin, 25, pageWidth - margin, 25);
        
        // Table header
        let threadY = 40;
        doc.setFontSize(10);
        doc.setTextColor(50, 50, 50);
        doc.setFont('helvetica', 'bold');
        doc.text('No.', margin, threadY);
        doc.text('Colour Name', margin + 20, threadY);
        doc.text('Colour', margin + 80, threadY);
        doc.text('Stitch Count', margin + 105, threadY);
        doc.text('Length (m)', margin + 140, threadY);
        doc.setFont('helvetica', 'normal');
        
        threadY += 5;
        doc.line(margin, threadY, pageWidth - margin, threadY);
        threadY += 8;
        
        colorsUsed.forEach(([color, count]) => {
          const dmc = DMC_COLORS[color] || { dmc: '---', name: color };
          const length = calculateThreadLength(count);
          
          doc.text(dmc.dmc, margin, threadY);
          doc.text(dmc.name, margin + 20, threadY);
          
          // Color swatch
          const hex = PALETTE[color]?.hex || '#ffffff';
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          doc.setFillColor(r, g, b);
          doc.rect(margin + 80, threadY - 4, 15, 5, 'F');
          
          doc.text(String(count), margin + 110, threadY);
          doc.text(length, margin + 145, threadY);
          
          threadY += 8;
        });
        
        // Total
        const totalStitches = colorsUsed.reduce((sum, [_, count]) => sum + count, 0);
        threadY += 5;
        doc.line(margin, threadY, pageWidth - margin, threadY);
        threadY += 8;
        doc.setFont('helvetica', 'bold');
        doc.text('Total:', margin + 80, threadY);
        doc.text(String(totalStitches), margin + 110, threadY);
        doc.text(calculateThreadLength(totalStitches), margin + 145, threadY);
        
        addFooterLogo();
        
        // Save PDF
        doc.save(designName + '_stitch_guide.pdf');
        setShowDownloadMenu(false);
      };

      const exportDesign = () => {
        setShowDownloadMenu(true);
      };

      const getTouchDistance = (t1, t2) => {
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      };

      const getTouchCenter = (t1, t2) => ({
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      });

      // Wheel zoom
      const handleWheel = useCallback((e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.975 : 1.025;
        
        const rect = workspaceRef.current.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const contentX = (mouseX - pan.x - 100) / zoom;
        const contentY = (mouseY - pan.y - 100) / zoom;
        
        const newZoom = Math.min(4, Math.max(0.2, zoom * delta));
        
        const newPanX = mouseX - 100 - contentX * newZoom;
        const newPanY = mouseY - 100 - contentY * newZoom;
        
        setZoom(newZoom);
        setPan({ x: newPanX, y: newPanY });
      }, [zoom, pan]);

      // Touch handlers
      const handleTouchStart = useCallback((e) => {
        if (e.touches.length === 2) {
          // Pinch zoom/pan - stop any painting and allow anywhere
          isPaintingRef.current = false;
          setIsPainting(false);
          e.preventDefault();
          const dist = getTouchDistance(e.touches[0], e.touches[1]);
          const center = getTouchCenter(e.touches[0], e.touches[1]);
          pinchStartRef.current = { 
            distance: dist, 
            zoom: zoom,
            panX: pan.x,
            panY: pan.y,
            centerX: center.x,
            centerY: center.y
          };
          setTouchMode('pinch');
        } else if (e.touches.length === 1) {
          // If already painting on grid, don't interfere
          if (isPaintingRef.current) return;
          
          const target = e.target;
          
          // If panOnly mode is enabled, always pan with one finger (even on grid)
          if (panOnly) {
            setTouchMode('pan');
            panStartRef.current = { 
              x: e.touches[0].clientX, 
              y: e.touches[0].clientY, 
              panX: pan.x, 
              panY: pan.y 
            };
            lastTouchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return;
          }
          
          // Check if touching inside the grid - let document-level grid handler manage painting
          const gridEl = gridRef.current;
          if (gridEl) {
            const rect = gridEl.getBoundingClientRect();
            const touch = e.touches[0];
            if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
              setTouchMode('paint');
              return; // Let the document-level grid touch handlers work
            }
          }
          
          const isWorkspace = target === workspaceRef.current || 
                             target === contentRef.current || 
                             target.classList.contains('workspace-bg');
          
          if (isWorkspace) {
            // Pan with single finger on empty space
            setTouchMode('pan');
            panStartRef.current = { 
              x: e.touches[0].clientX, 
              y: e.touches[0].clientY, 
              panX: pan.x, 
              panY: pan.y 
            };
          }
          lastTouchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      }, [zoom, pan, panOnly]);

      const handleTouchMove = useCallback((e) => {
        if (touchMode === 'pinch' && e.touches.length === 2) {
          e.preventDefault();
          const dist = getTouchDistance(e.touches[0], e.touches[1]);
          const center = getTouchCenter(e.touches[0], e.touches[1]);
          
          const scale = dist / pinchStartRef.current.distance;
          const newZoom = Math.min(4, Math.max(0.2, pinchStartRef.current.zoom * scale));
          
          // Pan while pinching
          const dx = center.x - pinchStartRef.current.centerX;
          const dy = center.y - pinchStartRef.current.centerY;
          
          setZoom(newZoom);
          setPan({ 
            x: pinchStartRef.current.panX + dx, 
            y: pinchStartRef.current.panY + dy 
          });
        } else if (touchMode === 'pan' && e.touches.length === 1) {
          const dx = e.touches[0].clientX - panStartRef.current.x;
          const dy = e.touches[0].clientY - panStartRef.current.y;
          setPan({ 
            x: panStartRef.current.panX + dx, 
            y: panStartRef.current.panY + dy 
          });
        } else if (touchMode === 'paint' && e.touches.length === 1) {
          // Let the grid cell handlers manage painting
          // Just track position for reference
          lastTouchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          return; // Don't prevent any default behavior
        }
        
        if (e.touches.length === 1) {
          lastTouchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      }, [touchMode]);

      const handleTouchEnd = useCallback((e) => {
        if (e.touches.length === 0) {
          if (isPainting && grid) saveHistory(grid);
          setIsPainting(false);
          setTouchMode(null);
        } else if (e.touches.length === 1) {
          // Switched from pinch to single finger - start pan
          setTouchMode('pan');
          panStartRef.current = { 
            x: e.touches[0].clientX, 
            y: e.touches[0].clientY, 
            panX: pan.x, 
            panY: pan.y 
          };
        }
      }, [isPainting, grid, saveHistory, pan]);

      // Mouse handlers for desktop
      const handleMouseDown = (e) => {
        const isWorkspace = e.target === workspaceRef.current || 
                           e.target === contentRef.current || 
                           e.target.classList.contains('workspace-bg');
        if (isWorkspace) {
          e.preventDefault();
          setIsPanning(true);
          panStartRef.current = { x: e.clientX, y: e.clientY, panX: pan.x, panY: pan.y };
        }
      };

      const handleMouseMove = useCallback((e) => {
        if (isPanning && !isDraggingImage && !isResizingImage && !isDraggingCrop) {
          const dx = e.clientX - panStartRef.current.x;
          const dy = e.clientY - panStartRef.current.y;
          setPan({ x: panStartRef.current.panX + dx, y: panStartRef.current.panY + dy });
        }
        if (isDraggingImage && !refImageLocked) {
          const dx = (e.clientX - imgDragStartRef.current.x) / zoom;
          const dy = (e.clientY - imgDragStartRef.current.y) / zoom;
          setRefImagePosition({ x: imgDragStartRef.current.imgX + dx, y: imgDragStartRef.current.imgY + dy });
        }
        if (isResizingImage && !refImageLocked) {
          const dx = (e.clientX - imgResizeStartRef.current.x) / zoom;
          const dy = (e.clientY - imgResizeStartRef.current.y) / zoom;
          setRefImageSize({ width: Math.max(50, imgResizeStartRef.current.w + dx), height: Math.max(50, imgResizeStartRef.current.h + dy) });
        }
        if (isDraggingCrop && cropDragType) {
          const dx = (e.clientX - cropStartRef.current.x) / zoom;
          const dy = (e.clientY - cropStartRef.current.y) / zoom;
          const box = cropStartRef.current.box;
          
          let newBox = { ...cropBox };
          
          if (cropDragType === 'move') {
            newBox.x = Math.max(0, Math.min(refImageSize.width - box.w, box.x + dx));
            newBox.y = Math.max(0, Math.min(refImageSize.height - box.h, box.y + dy));
          } else if (cropDragType === 'nw') {
            const newX = Math.max(0, Math.min(box.x + box.w - 20, box.x + dx));
            const newY = Math.max(0, Math.min(box.y + box.h - 20, box.y + dy));
            newBox = { x: newX, y: newY, w: box.x + box.w - newX, h: box.y + box.h - newY };
          } else if (cropDragType === 'ne') {
            const newW = Math.max(20, Math.min(refImageSize.width - box.x, box.w + dx));
            const newY = Math.max(0, Math.min(box.y + box.h - 20, box.y + dy));
            newBox = { x: box.x, y: newY, w: newW, h: box.y + box.h - newY };
          } else if (cropDragType === 'sw') {
            const newX = Math.max(0, Math.min(box.x + box.w - 20, box.x + dx));
            const newH = Math.max(20, Math.min(refImageSize.height - box.y, box.h + dy));
            newBox = { x: newX, y: box.y, w: box.x + box.w - newX, h: newH };
          } else if (cropDragType === 'se') {
            const newW = Math.max(20, Math.min(refImageSize.width - box.x, box.w + dx));
            const newH = Math.max(20, Math.min(refImageSize.height - box.y, box.h + dy));
            newBox = { x: box.x, y: box.y, w: newW, h: newH };
          }
          
          setCropBox(newBox);
        }
      }, [isPanning, isDraggingImage, isResizingImage, isDraggingCrop, cropDragType, zoom, refImageLocked, refImageSize, cropBox]);

      const handleMouseUp = useCallback(() => {
        if (isPainting && grid) saveHistory(grid);
        setIsPainting(false);
        setIsDraggingImage(false);
        setIsResizingImage(false);
        setIsPanning(false);
        setIsDraggingCrop(false);
        setCropDragType(null);
      }, [isPainting, grid, saveHistory]);

      useEffect(() => {
        const workspace = workspaceRef.current;
        if (workspace) {
          workspace.addEventListener('wheel', handleWheel, { passive: false });
          workspace.addEventListener('touchstart', handleTouchStart, { passive: false });
          workspace.addEventListener('touchmove', handleTouchMove, { passive: false });
          workspace.addEventListener('touchend', handleTouchEnd, { passive: false });
        }
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
        
        return () => {
          if (workspace) {
            workspace.removeEventListener('wheel', handleWheel);
            workspace.removeEventListener('touchstart', handleTouchStart);
            workspace.removeEventListener('touchmove', handleTouchMove);
            workspace.removeEventListener('touchend', handleTouchEnd);
          }
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('mouseup', handleMouseUp);
        };
      }, [handleWheel, handleTouchStart, handleTouchMove, handleTouchEnd, handleMouseMove, handleMouseUp]);

      // Grid touch painting - using document-level listeners for reliability
      const isPaintingRef = useRef(false);
      const lastPaintedCell = useRef(null);
      const paintFnRef = useRef(paintWithBrush);
      const gridDimsRef = useRef({ width: 0, height: 0 });
      const zoomRef = useRef(zoom);
      const gridExistsRef = useRef(false);
      const saveHistoryRef = useRef(saveHistory);
      const currentGridRef = useRef(grid);
      const cellSizeRef = useRef(cellSize);
      const activePanelRef = useRef(activePanel);
      const isMobileRef = useRef(isMobile);
      const panOnlyRef = useRef(panOnly);
      
      // Keep refs updated
      useEffect(() => {
        paintFnRef.current = paintWithBrush;
      }, [paintWithBrush]);
      
      useEffect(() => {
        zoomRef.current = zoom;
      }, [zoom]);
      
      useEffect(() => {
        saveHistoryRef.current = saveHistory;
      }, [saveHistory]);
      
      useEffect(() => {
        activePanelRef.current = activePanel;
      }, [activePanel]);
      
      useEffect(() => {
        isMobileRef.current = isMobile;
      }, [isMobile]);
      
      useEffect(() => {
        panOnlyRef.current = panOnly;
      }, [panOnly]);
      
      useEffect(() => {
        cellSizeRef.current = cellSize;
      }, [cellSize]);
      
      useEffect(() => {
        currentGridRef.current = grid;
        if (grid) {
          gridDimsRef.current = { width: grid[0].length, height: grid.length };
          gridExistsRef.current = true;
        } else {
          gridExistsRef.current = false;
        }
      }, [grid]);
      
      // Document-level touch handlers for grid painting
      useEffect(() => {
        const getCellFromTouch = (touch) => {
          const gridEl = gridRef.current;
          if (!gridEl || !gridExistsRef.current) return null;
          const rect = gridEl.getBoundingClientRect();
          const dims = gridDimsRef.current;
          const currentZoom = zoomRef.current;
          const cs = cellSizeRef.current;
          const x = Math.floor((touch.clientX - rect.left) / (cs * currentZoom));
          const y = Math.floor((touch.clientY - rect.top) / (cs * currentZoom));
          if (x >= 0 && x < dims.width && y >= 0 && y < dims.height) {
            return { x, y };
          }
          return null;
        };
        
        const isInsideGrid = (touch) => {
          const gridEl = gridRef.current;
          if (!gridEl) return false;
          const rect = gridEl.getBoundingClientRect();
          return touch.clientX >= rect.left && touch.clientX <= rect.right &&
                 touch.clientY >= rect.top && touch.clientY <= rect.bottom;
        };
        
        const handleDocTouchStart = (e) => {
          // Record touch start time
          touchStartTimeRef.current = Date.now();
          
          // If already 2 touches, cancel any pending paint and don't paint
          if (e.touches.length === 2) {
            if (pendingPaintRef.current) {
              clearTimeout(pendingPaintRef.current);
              pendingPaintRef.current = null;
            }
            isPaintingRef.current = false;
            setIsPainting(false);
            return;
          }
          
          // Don't paint if a mobile panel is open
          if (activePanelRef.current) return;
          
          // Don't paint if pan-only mode is enabled
          if (panOnlyRef.current) return;
          
          // Don't paint if touching the bottom nav area on mobile (bottom 56px + some buffer)
          if (isMobileRef.current) {
            const touch = e.touches[0];
            const bottomNavHeight = 70; // 56px nav + some buffer
            if (touch.clientY > window.innerHeight - bottomNavHeight) return;
          }
          
          if (e.touches.length === 1 && gridExistsRef.current) {
            // Check if touch started inside the grid
            if (isInsideGrid(e.touches[0])) {
              e.preventDefault();
              
              // Store touch info for potential delayed paint
              const touchInfo = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
              };
              
              // Mark that we're ready to paint (but haven't painted yet)
              isPaintingRef.current = 'pending';
              
              // Store the cell info for tap detection
              pendingPaintRef.current = {
                touchInfo,
                cell: getCellFromTouch(touchInfo),
                timeout: setTimeout(() => {
                  // After 80ms with no second finger, commit to painting mode
                  if (isPaintingRef.current === 'pending') {
                    isPaintingRef.current = true;
                    setIsPainting(true);
                  }
                }, 80)
              };
            }
          }
        };
        
        const handleDocTouchMove = (e) => {
          // If 2 touches detected during move, cancel painting
          if (e.touches.length === 2) {
            if (pendingPaintRef.current?.timeout) {
              clearTimeout(pendingPaintRef.current.timeout);
            }
            pendingPaintRef.current = null;
            isPaintingRef.current = false;
            setIsPainting(false);
            return;
          }
          
          // If we're in pending state and user starts moving, start painting
          if (e.touches.length === 1 && isPaintingRef.current === 'pending') {
            isPaintingRef.current = true;
            setIsPainting(true);
            // Paint the first cell now
            if (pendingPaintRef.current?.cell) {
              const cell = pendingPaintRef.current.cell;
              lastPaintedCell.current = `${cell.x},${cell.y}`;
              paintFnRef.current(cell.x, cell.y);
            }
          }
          
          if (e.touches.length === 1 && isPaintingRef.current === true) {
            e.preventDefault();
            const cell = getCellFromTouch(e.touches[0]);
            if (cell) {
              const cellKey = `${cell.x},${cell.y}`;
              // Only paint if we moved to a new cell
              if (cellKey !== lastPaintedCell.current) {
                lastPaintedCell.current = cellKey;
                paintFnRef.current(cell.x, cell.y);
              }
            }
          }
        };
        
        const handleDocTouchEnd = (e) => {
          // If we were in pending state (tap without drag), paint the cell now
          if (isPaintingRef.current === 'pending' && pendingPaintRef.current?.cell) {
            const cell = pendingPaintRef.current.cell;
            paintFnRef.current(cell.x, cell.y);
            // Save history
            if (currentGridRef.current) {
              saveHistoryRef.current(currentGridRef.current);
            }
          }
          
          // Clear any pending timeout
          if (pendingPaintRef.current?.timeout) {
            clearTimeout(pendingPaintRef.current.timeout);
          }
          pendingPaintRef.current = null;
          
          if (isPaintingRef.current === true) {
            // Save history with current grid
            if (currentGridRef.current) {
              saveHistoryRef.current(currentGridRef.current);
            }
          }
          
          isPaintingRef.current = false;
          lastPaintedCell.current = null;
          setIsPainting(false);
        };
        
        // Attach to document so they persist through re-renders
        document.addEventListener('touchstart', handleDocTouchStart, { passive: false });
        document.addEventListener('touchmove', handleDocTouchMove, { passive: false });
        document.addEventListener('touchend', handleDocTouchEnd, { passive: false });
        
        return () => {
          document.removeEventListener('touchstart', handleDocTouchStart);
          document.removeEventListener('touchmove', handleDocTouchMove);
          document.removeEventListener('touchend', handleDocTouchEnd);
        };
      }, []); // Empty dependency - only set up once

      // Keyboard shortcuts
      useEffect(() => {
        if (!isCropping) return;
        const handleKeyDown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            applyCrop();
          } else if (e.key === 'Escape') {
            e.preventDefault();
            cancelCrop();
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      });

      const e = React.createElement;

      // Icons (larger for touch)
      const Icon = ({ d, size = 20 }) => e('svg', { width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' }, e('path', { d }));
      const MenuIcon = () => Icon({ d: 'M3 12h18M3 6h18M3 18h18' });
      const GridIcon = () => Icon({ d: 'M3 3h7v7H3zM14 3h7v7h-7zM14 14h7v7h-7zM3 14h7v7H3z' });
      const DownloadIcon = () => Icon({ d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3' });
      const UndoIcon = () => Icon({ d: 'M1 4v6h6M1 10C1 5.58 4.58 2 9 2c4.42 0 8 3.58 8 8s-3.58 8-8 8c-2.21 0-4.21-.9-5.66-2.34' });
      const RedoIcon = () => Icon({ d: 'M23 4v6h-6M23 10c0-4.42-3.58-8-8-8-4.42 0-8 3.58-8 8s3.58 8 8 8c2.21 0 4.21-.9 5.66-2.34' });
      const ZoomInIcon = () => Icon({ d: 'M11 3a8 8 0 1 0 0 16 8 8 0 0 0 0-16zM21 21l-4.35-4.35M11 8v6M8 11h6' });
      const ZoomOutIcon = () => Icon({ d: 'M11 3a8 8 0 1 0 0 16 8 8 0 0 0 0-16zM21 21l-4.35-4.35M8 11h6' });
      const EyeIcon = () => Icon({ d: 'M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8zM12 9a3 3 0 1 0 0 6 3 3 0 0 0 0-6z' });
      const EyeOffIcon = () => Icon({ d: 'M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24M1 1l22 22' });
      const LockIcon = () => Icon({ d: 'M19 11H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2zM7 11V7a5 5 0 0 1 10 0v4' });
      const UnlockIcon = () => Icon({ d: 'M19 11H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2zM7 11V7a5 5 0 0 1 9.9-1' });
      const UploadIcon = () => Icon({ d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12' });
      const XIcon = () => Icon({ d: 'M18 6L6 18M6 6l12 12' });
      const CheckIcon = () => Icon({ d: 'M20 6L9 17l-5-5' });
      const SettingsIcon = () => Icon({ d: 'M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z' });
      const PaletteIcon = () => Icon({ d: 'M12 2a10 10 0 0 0-8.66 15 10 10 0 0 0 17.32 0A10 10 0 0 0 12 2zM12 12m-2 0a2 2 0 1 0 4 0 2 2 0 1 0-4 0' });
      const ImageIcon = () => Icon({ d: 'M5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2zM21 15l-5-5L5 21M8.5 10a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z' });
      const HomeIcon = () => Icon({ d: 'M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z' });
      const CropIcon = () => Icon({ d: 'M6 2v4H2v2h4v10h10v4h2v-4h4v-2H8V6h10v6h2V6a2 2 0 0 0-2-2H6V2' });
      const BrushIcon = () => Icon({ d: 'M9.06 11.9l8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08M9.06 11.9L5 22l10.1-4.06M9.06 11.9l4.03 4.03' });
      const PlusIcon = () => Icon({ d: 'M12 5v14M5 12h14' });
      const MinusIcon = () => Icon({ d: 'M5 12h14' });
      const MoveIcon = () => Icon({ d: 'M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3M2 12h20M12 2v20' });
      const SaveIcon = () => Icon({ d: 'M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2zM17 21v-8H7v8M7 3v5h8' });
      const TrashIcon = () => Icon({ d: 'M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2' });
      const FolderIcon = () => Icon({ d: 'M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z' });

      // Mobile bottom toolbar tab
      const TabButton = ({ icon, label, active, onClick }) => 
        e('button', { 
          onClick, 
          className: `flex-1 flex flex-col items-center justify-center py-2 px-1 ${active ? 'text-amber-500 bg-amber-50' : 'text-gray-600'}` 
        },
          icon,
          e('span', { className: 'text-[10px] mt-0.5' }, label)
        );

      return e('div', { className: 'h-screen bg-gray-50 text-gray-800 flex flex-col overflow-hidden' },
        // Header
        e('header', { className: 'bg-white border-b border-gray-200 py-2 px-3 flex items-center justify-between shrink-0 shadow-sm z-30' },
          e('div', { className: 'flex items-center gap-2' },
            e('button', { onClick: () => setShowSavedMenu(true), className: 'p-2 rounded hover:bg-gray-100 text-gray-600' }, e(MenuIcon)),
            e('div', { className: 'w-8 h-8 bg-amber-500 rounded-lg flex items-center justify-center text-white' }, e(GridIcon)),
            e('span', { className: 'font-bold text-sm hidden sm:block text-gray-800' }, 'Needlepoint'),
            e('input', { type: 'text', value: designName, onChange: (ev) => setDesignName(ev.target.value.replace(/[^a-zA-Z0-9]/g, '')), className: 'bg-gray-100 text-gray-800 px-2 py-1 rounded border border-gray-300 text-sm w-20 sm:w-28 focus:outline-none focus:border-amber-500' })
          ),
          e('div', { className: 'flex items-center gap-1' },
            // Save
            e('button', { onClick: saveDesign, disabled: !grid, className: 'p-2 rounded hover:bg-gray-100 disabled:opacity-30 text-gray-600', title: 'Save Design' }, e(SaveIcon)),
            // Undo/Redo
            e('button', { onClick: undo, disabled: historyIndex <= 0, className: 'p-2 rounded disabled:opacity-30 text-gray-600' }, e(UndoIcon)),
            e('button', { onClick: redo, disabled: historyIndex >= history.length - 1, className: 'p-2 rounded disabled:opacity-30 text-gray-600' }, e(RedoIcon)),
            // Export
            e('button', { onClick: exportDesign, disabled: !grid, className: 'p-2 bg-amber-500 hover:bg-amber-600 rounded disabled:opacity-50 text-white ml-1' }, e(DownloadIcon))
          )
        ),

        // Main area
        e('div', { className: 'flex flex-1 overflow-hidden relative' },
          // Desktop left sidebar
          !isMobile && e('aside', { className: 'w-52 bg-white border-r border-gray-200 p-3 overflow-y-auto shrink-0' },
            // Grid Setup
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Grid Setup'),
              e('div', { className: 'space-y-2' },
                e('select', { value: canvasCount, onChange: (ev) => setCanvasCount(Number(ev.target.value)), className: 'w-full px-2 py-1.5 bg-gray-100 border border-gray-300 rounded text-sm' },
                  e('option', { value: 13 }, '13 count'),
                  e('option', { value: 15 }, '15 count')
                ),
                e('div', { className: 'grid grid-cols-2 gap-2' },
                  e('div', null,
                    e('label', { className: 'text-xs text-gray-500' }, 'Width'),
                    e('input', { type: 'number', value: gridWidth, onChange: (ev) => setGridWidth(ev.target.value), className: 'w-full px-2 py-1 bg-gray-100 border border-gray-300 rounded text-sm', min: 0, max: maxCrosses })
                  ),
                  e('div', null,
                    e('label', { className: 'text-xs text-gray-500' }, 'Height'),
                    e('input', { type: 'number', value: gridHeight, onChange: (ev) => setGridHeight(ev.target.value), className: 'w-full px-2 py-1 bg-gray-100 border border-gray-300 rounded text-sm', min: 0, max: maxCrosses })
                  )
                ),
                e('p', { className: 'text-xs text-gray-500' }, `${(parsedWidth/crossesPerInch).toFixed(2)}" × ${(parsedHeight/crossesPerInch).toFixed(2)}"`),
                e('button', { onClick: createGrid, disabled: parsedWidth < 1 || parsedHeight < 1, className: 'w-full py-2 bg-amber-500 hover:bg-amber-600 disabled:bg-gray-300 rounded text-sm font-medium text-white' }, grid ? 'Reset Grid' : 'Create Grid')
              )
            ),

            // Size adjust (desktop)
            grid && e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Adjust Size'),
              e('div', { className: 'space-y-2 text-xs' },
                e('div', null,
                  e('span', { className: 'text-gray-500 block mb-1' }, 'Rows'),
                  e('div', { className: 'flex gap-1' },
                    e('button', { onClick: addRowTop, className: 'flex-1 py-1.5 bg-green-100 hover:bg-green-200 rounded border border-green-300 text-green-700' }, '+↑'),
                    e('button', { onClick: addRowBottom, className: 'flex-1 py-1.5 bg-green-100 hover:bg-green-200 rounded border border-green-300 text-green-700' }, '+↓'),
                    e('button', { onClick: removeRowTop, className: 'flex-1 py-1.5 bg-red-100 hover:bg-red-200 rounded border border-red-300 text-red-700' }, '-↑'),
                    e('button', { onClick: removeRowBottom, className: 'flex-1 py-1.5 bg-red-100 hover:bg-red-200 rounded border border-red-300 text-red-700' }, '-↓')
                  )
                ),
                e('div', null,
                  e('span', { className: 'text-gray-500 block mb-1' }, 'Columns'),
                  e('div', { className: 'flex gap-1' },
                    e('button', { onClick: addColLeft, className: 'flex-1 py-1.5 bg-green-100 hover:bg-green-200 rounded border border-green-300 text-green-700' }, '+←'),
                    e('button', { onClick: addColRight, className: 'flex-1 py-1.5 bg-green-100 hover:bg-green-200 rounded border border-green-300 text-green-700' }, '+→'),
                    e('button', { onClick: removeColLeft, className: 'flex-1 py-1.5 bg-red-100 hover:bg-red-200 rounded border border-red-300 text-red-700' }, '-←'),
                    e('button', { onClick: removeColRight, className: 'flex-1 py-1.5 bg-red-100 hover:bg-red-200 rounded border border-red-300 text-red-700' }, '-→')
                  )
                ),
                e('p', { className: 'text-gray-500 mt-1 text-center' }, `${grid[0].length} × ${grid.length}`)
              )
            ),

            // View controls (desktop)
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'View'),
              e('div', { className: 'space-y-2' },
                e('div', { className: 'flex items-center gap-1' },
                  e('button', { onClick: () => setZoom(z => Math.max(0.2, z * 0.8)), className: 'p-2 bg-gray-100 rounded border border-gray-300' }, e(ZoomOutIcon)),
                  e('span', { className: 'flex-1 text-xs text-center' }, Math.round(zoom * 100) + '%'),
                  e('button', { onClick: () => setZoom(z => Math.min(4, z * 1.25)), className: 'p-2 bg-gray-100 rounded border border-gray-300' }, e(ZoomInIcon))
                ),
                e('div', null,
                  e('div', { className: 'flex items-center justify-between mb-1' },
                    e('span', { className: 'text-xs text-gray-500' }, 'Opacity'),
                    e('span', { className: 'text-xs text-gray-400' }, Math.round(canvasOpacity * 100) + '%')
                  ),
                  e('input', { type: 'range', min: 0.1, max: 1, step: 0.05, value: canvasOpacity, onChange: (ev) => setCanvasOpacity(parseFloat(ev.target.value)), className: 'w-full' })
                ),
                e('button', { onClick: () => { setZoom(1); setPan({ x: 0, y: 0 }); }, className: 'w-full py-1.5 text-xs bg-gray-100 rounded border border-gray-300 flex items-center justify-center gap-1' }, e(HomeIcon), 'Reset View')
              )
            )
          ),

          // Workspace
          e('main', { 
            ref: workspaceRef,
            className: 'flex-1 overflow-hidden bg-gray-200 relative',
            style: { cursor: isPanning ? 'grabbing' : 'grab' },
            onMouseDown: handleMouseDown
          },
            // Background
            e('div', { 
              className: 'workspace-bg absolute',
              style: {
                width: '300%', height: '300%', left: '-100%', top: '-100%',
                backgroundImage: 'radial-gradient(circle, #d1d5db 1px, transparent 1px)',
                backgroundSize: `${20 * zoom}px ${20 * zoom}px`,
                transform: `translate(${pan.x}px, ${pan.y}px)`,
                pointerEvents: 'all'
              }
            }),
            
            // Content container
            e('div', { 
              ref: contentRef,
              className: 'absolute',
              style: { 
                transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                transformOrigin: '0 0',
                left: '50px', top: '50px',
                pointerEvents: 'none'
              }
            },
              // Reference Image
              refImage && showRefImage && e('div', {
                className: `absolute border-2 ${isPositioningImage ? 'border-green-500 border-dashed' : refImageLocked ? 'border-gray-400' : 'border-amber-500'} rounded shadow-lg`,
                style: { 
                  left: refImagePosition.x, top: refImagePosition.y, 
                  width: refImageSize.width, height: refImageSize.height, 
                  zIndex: isPositioningImage ? 10 : 1, 
                  cursor: refImageLocked && !isPositioningImage ? 'default' : 'move',
                  pointerEvents: isCropping ? 'none' : 'auto'
                },
                onMouseDown: (ev) => {
                  if (isCropping) return;
                  if (refImageLocked && !isPositioningImage) {
                    ev.stopPropagation();
                    setIsPanning(true);
                    panStartRef.current = { x: ev.clientX, y: ev.clientY, panX: pan.x, panY: pan.y };
                    return;
                  }
                  ev.stopPropagation();
                  setIsDraggingImage(true);
                  imgDragStartRef.current = { x: ev.clientX, y: ev.clientY, imgX: refImagePosition.x, imgY: refImagePosition.y };
                },
                onTouchStart: (ev) => {
                  if (isCropping || ev.touches.length !== 1) return;
                  if (refImageLocked && !isPositioningImage) return;
                  ev.stopPropagation();
                  setIsDraggingImage(true);
                  imgDragStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, imgX: refImagePosition.x, imgY: refImagePosition.y };
                },
                onTouchMove: (ev) => {
                  if (!isDraggingImage || (refImageLocked && !isPositioningImage)) return;
                  const dx = (ev.touches[0].clientX - imgDragStartRef.current.x) / zoom;
                  const dy = (ev.touches[0].clientY - imgDragStartRef.current.y) / zoom;
                  setRefImagePosition({ x: imgDragStartRef.current.imgX + dx, y: imgDragStartRef.current.imgY + dy });
                },
                onTouchEnd: () => setIsDraggingImage(false)
              },
                e('img', { src: refImage, alt: 'Reference', className: 'w-full h-full object-contain pointer-events-none rounded', draggable: false }),
                // Resize handle - show during positioning mode OR when not locked
                (isPositioningImage || !refImageLocked) && !isCropping && e('div', {
                  className: `absolute bottom-0 right-0 w-10 h-10 ${isPositioningImage ? 'bg-green-500' : 'bg-amber-500'} cursor-nwse-resize rounded-tl rounded-br flex items-center justify-center`,
                  onMouseDown: (ev) => {
                    ev.stopPropagation();
                    setIsResizingImage(true);
                    imgResizeStartRef.current = { w: refImageSize.width, h: refImageSize.height, x: ev.clientX, y: ev.clientY };
                  },
                  onTouchStart: (ev) => {
                    ev.stopPropagation();
                    if (ev.touches.length === 1) {
                      setIsResizingImage(true);
                      imgResizeStartRef.current = { w: refImageSize.width, h: refImageSize.height, x: ev.touches[0].clientX, y: ev.touches[0].clientY };
                    }
                  },
                  onTouchMove: (ev) => {
                    ev.stopPropagation();
                    if (isResizingImage && ev.touches.length === 1) {
                      const dx = (ev.touches[0].clientX - imgResizeStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - imgResizeStartRef.current.y) / zoom;
                      setRefImageSize({ width: Math.max(50, imgResizeStartRef.current.w + dx), height: Math.max(50, imgResizeStartRef.current.h + dy) });
                    }
                  },
                  onTouchEnd: (ev) => {
                    ev.stopPropagation();
                    setIsResizingImage(false);
                  }
                }, e('span', { className: 'text-white text-sm' }, '⤡')),
                // Additional corner resize handles during positioning mode
                isPositioningImage && e('div', {
                  className: 'absolute top-0 left-0 w-8 h-8 bg-green-500 cursor-nwse-resize rounded-br flex items-center justify-center',
                  onMouseDown: (ev) => {
                    ev.stopPropagation();
                    setIsResizingImage(true);
                    imgResizeStartRef.current = { w: refImageSize.width, h: refImageSize.height, x: ev.clientX, y: ev.clientY, corner: 'tl', imgX: refImagePosition.x, imgY: refImagePosition.y };
                  },
                  onTouchStart: (ev) => {
                    ev.stopPropagation();
                    if (ev.touches.length === 1) {
                      setIsResizingImage(true);
                      imgResizeStartRef.current = { w: refImageSize.width, h: refImageSize.height, x: ev.touches[0].clientX, y: ev.touches[0].clientY, corner: 'tl', imgX: refImagePosition.x, imgY: refImagePosition.y };
                    }
                  }
                }, e('span', { className: 'text-white text-xs' }, '⤢'))
              ),
              
              // Crop overlay
              refImage && isCropping && e('div', { 
                className: 'absolute',
                style: { 
                  left: refImagePosition.x, top: refImagePosition.y, 
                  width: refImageSize.width, height: refImageSize.height,
                  pointerEvents: 'auto', zIndex: 10 
                }
              },
                e('div', { className: 'absolute inset-0 bg-black/50', style: { borderRadius: '0.25rem' } }),
                e('div', {
                  className: 'absolute border-2 border-white cursor-move',
                  style: { 
                    left: cropBox.x, top: cropBox.y, 
                    width: cropBox.w, height: cropBox.h,
                    backgroundColor: 'transparent',
                    boxShadow: '0 0 0 9999px rgba(0,0,0,0.5)'
                  },
                  onMouseDown: (ev) => {
                    ev.stopPropagation();
                    setIsDraggingCrop(true);
                    setCropDragType('move');
                    cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } };
                  },
                  onTouchStart: (ev) => {
                    if (ev.touches.length !== 1) return;
                    ev.stopPropagation();
                    setIsDraggingCrop(true);
                    setCropDragType('move');
                    cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } };
                  },
                  onTouchMove: (ev) => {
                    if (!isDraggingCrop || cropDragType !== 'move') return;
                    const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                    const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                    const box = cropStartRef.current.box;
                    setCropBox({
                      ...box,
                      x: Math.max(0, Math.min(refImageSize.width - box.w, box.x + dx)),
                      y: Math.max(0, Math.min(refImageSize.height - box.h, box.y + dy))
                    });
                  },
                  onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                },
                  // Corner handles - bigger for touch with touch handlers
                  e('div', { 
                    className: 'crop-handle', 
                    style: { top: -12, left: -12, width: 24, height: 24, cursor: 'nwse-resize' }, 
                    onMouseDown: (ev) => { ev.stopPropagation(); setIsDraggingCrop(true); setCropDragType('nw'); cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } }; },
                    onTouchStart: (ev) => { ev.stopPropagation(); if (ev.touches.length === 1) { setIsDraggingCrop(true); setCropDragType('nw'); cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } }; } },
                    onTouchMove: (ev) => {
                      ev.stopPropagation();
                      if (!isDraggingCrop || cropDragType !== 'nw') return;
                      const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                      const box = cropStartRef.current.box;
                      const newX = Math.max(0, Math.min(box.x + box.w - 20, box.x + dx));
                      const newY = Math.max(0, Math.min(box.y + box.h - 20, box.y + dy));
                      setCropBox({ x: newX, y: newY, w: box.x + box.w - newX, h: box.y + box.h - newY });
                    },
                    onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                  }),
                  e('div', { 
                    className: 'crop-handle', 
                    style: { top: -12, right: -12, width: 24, height: 24, cursor: 'nesw-resize' }, 
                    onMouseDown: (ev) => { ev.stopPropagation(); setIsDraggingCrop(true); setCropDragType('ne'); cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } }; },
                    onTouchStart: (ev) => { ev.stopPropagation(); if (ev.touches.length === 1) { setIsDraggingCrop(true); setCropDragType('ne'); cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } }; } },
                    onTouchMove: (ev) => {
                      ev.stopPropagation();
                      if (!isDraggingCrop || cropDragType !== 'ne') return;
                      const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                      const box = cropStartRef.current.box;
                      const newW = Math.max(20, Math.min(refImageSize.width - box.x, box.w + dx));
                      const newY = Math.max(0, Math.min(box.y + box.h - 20, box.y + dy));
                      setCropBox({ x: box.x, y: newY, w: newW, h: box.y + box.h - newY });
                    },
                    onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                  }),
                  e('div', { 
                    className: 'crop-handle', 
                    style: { bottom: -12, left: -12, width: 24, height: 24, cursor: 'nesw-resize' }, 
                    onMouseDown: (ev) => { ev.stopPropagation(); setIsDraggingCrop(true); setCropDragType('sw'); cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } }; },
                    onTouchStart: (ev) => { ev.stopPropagation(); if (ev.touches.length === 1) { setIsDraggingCrop(true); setCropDragType('sw'); cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } }; } },
                    onTouchMove: (ev) => {
                      ev.stopPropagation();
                      if (!isDraggingCrop || cropDragType !== 'sw') return;
                      const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                      const box = cropStartRef.current.box;
                      const newX = Math.max(0, Math.min(box.x + box.w - 20, box.x + dx));
                      const newH = Math.max(20, Math.min(refImageSize.height - box.y, box.h + dy));
                      setCropBox({ x: newX, y: box.y, w: box.x + box.w - newX, h: newH });
                    },
                    onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                  }),
                  e('div', { 
                    className: 'crop-handle', 
                    style: { bottom: -12, right: -12, width: 24, height: 24, cursor: 'nwse-resize' }, 
                    onMouseDown: (ev) => { ev.stopPropagation(); setIsDraggingCrop(true); setCropDragType('se'); cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } }; },
                    onTouchStart: (ev) => { ev.stopPropagation(); if (ev.touches.length === 1) { setIsDraggingCrop(true); setCropDragType('se'); cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } }; } },
                    onTouchMove: (ev) => {
                      ev.stopPropagation();
                      if (!isDraggingCrop || cropDragType !== 'se') return;
                      const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                      const box = cropStartRef.current.box;
                      const newW = Math.max(20, Math.min(refImageSize.width - box.x, box.w + dx));
                      const newH = Math.max(20, Math.min(refImageSize.height - box.y, box.h + dy));
                      setCropBox({ x: box.x, y: box.y, w: newW, h: newH });
                    },
                    onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                  })
                )
              ),

              // Grid
              grid && showCanvas && e('div', { 
                className: 'absolute', 
                style: { 
                  zIndex: isPositioningImage ? 5 : (isCropping ? 1.5 : 2),
                  opacity: isPositioningImage ? 1 : canvasOpacity, 
                  left: gridOffset.x, top: gridOffset.y, 
                  pointerEvents: (isCropping || isPositioningImage) ? 'none' : 'auto'
                }
              },
                e('div', {
                  ref: gridRef,
                  className: 'inline-grid border-2 border-gray-400 rounded shadow-md',
                  style: { gridTemplateColumns: `repeat(${grid[0].length}, ${cellSize}px)`, backgroundColor: 'transparent' },
                  onMouseLeave: () => { setIsPainting(false); setShowBrushCursor(false); },
                  onMouseEnter: () => { if (brushSize > 1) setShowBrushCursor(true); },
                  onMouseMove: (ev) => { setMousePos({ x: ev.clientX, y: ev.clientY }); }
                },
                  grid.map((row, y) => row.map((colorName, x) =>
                    e('div', {
                      key: `${x}-${y}`,
                      className: 'grid-cell border border-gray-300/50',
                      style: { 
                        width: cellSize, height: cellSize, 
                        backgroundColor: PALETTE[colorName]?.hex || '#ffffff', 
                        cursor: brushSize === 1 ? 'crosshair' : 'none' 
                      },
                      onMouseDown: (ev) => { ev.stopPropagation(); setIsPainting(true); paintWithBrush(x, y); },
                      onMouseEnter: () => { if (isPainting) paintWithBrush(x, y); },
                      onContextMenu: (ev) => { ev.preventDefault(); fillRegion(x, y); }
                    })
                  ))
                )
              ),

              // Empty state
              !grid && !refImage && e('div', { 
                className: 'bg-white rounded-xl p-6 shadow-sm border border-gray-200',
                style: { pointerEvents: 'auto' }
              },
                e('div', { className: 'mx-auto mb-3 text-gray-400 w-12 h-12 flex items-center justify-center' }, e(GridIcon)),
                e('h3', { className: 'text-base font-semibold text-gray-600 mb-1 text-center' }, 'No Grid Yet'),
                e('p', { className: 'text-gray-400 text-sm text-center' }, 'Create a grid to start')
              )
            ),

            // Crop action buttons (floating) - higher on mobile to avoid nav
            isCropping && e('div', { 
              className: 'absolute left-1/2 transform -translate-x-1/2 flex gap-2 z-20',
              style: { bottom: isMobile ? 80 : 16 }
            },
              e('button', { onClick: applyCrop, className: 'px-4 py-3 bg-green-500 text-white rounded-lg flex items-center gap-2 shadow-lg text-base' }, e(CheckIcon), 'Apply'),
              e('button', { onClick: cancelCrop, className: 'px-4 py-3 bg-gray-500 text-white rounded-lg flex items-center gap-2 shadow-lg text-base' }, e(XIcon), 'Cancel')
            ),

            // Positioning mode finish button
            isPositioningImage && e('div', { 
              className: 'absolute left-1/2 transform -translate-x-1/2 z-20',
              style: { bottom: isMobile ? 80 : 16 }
            },
              e('button', { 
                onClick: finishPositioning, 
                className: 'px-6 py-3 bg-green-500 hover:bg-green-600 text-white rounded-xl flex items-center gap-2 shadow-lg text-base font-medium'
              }, 
                e(CheckIcon), 
                'Done Positioning'
              )
            )
          ),

          // Desktop right sidebar
          !isMobile && e('aside', { className: 'w-52 bg-white border-l border-gray-200 p-3 overflow-y-auto shrink-0' },
            // Colors
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Colors'),
              e('div', { className: 'grid grid-cols-4 gap-1.5 mb-2' },
                PALETTE_ORDER.map(name =>
                  e('button', {
                    key: name,
                    onClick: () => setSelectedColor(name),
                    className: `aspect-square rounded-lg border-2 relative shadow-sm ${selectedColor === name ? 'border-amber-500 scale-105' : 'border-gray-300'}`,
                    style: { backgroundColor: PALETTE[name].hex }
                  },
                    usedColors[name] > 0 && e('span', { className: 'absolute -top-1 -right-1 min-w-4 h-4 bg-amber-500 rounded-full text-[8px] font-bold flex items-center justify-center text-white px-0.5' }, usedColors[name])
                  )
                )
              ),
              e('div', { className: 'bg-gray-100 rounded-lg p-2 flex items-center gap-2' },
                e('div', { className: 'w-8 h-8 rounded-lg border-2 border-gray-300', style: { backgroundColor: PALETTE[selectedColor].hex } }),
                e('span', { className: 'text-sm font-medium' }, selectedColor)
              )
            ),

            // Brush size
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Brush Size'),
              e('div', { className: 'flex items-center gap-2' },
                e('span', { className: 'text-xs' }, '1'),
                e('input', { type: 'range', min: 1, max: 10, value: brushSize, onChange: (ev) => setBrushSize(parseInt(ev.target.value)), className: 'flex-1' }),
                e('span', { className: 'text-xs' }, '10')
              ),
              e('p', { className: 'text-xs text-gray-400 text-center' }, `${brushSize}px`)
            ),

            // Reference Image
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Reference'),
              e('input', { ref: refImageInputRef, type: 'file', accept: 'image/*', onChange: handleRefUpload, className: 'hidden' }),
              !refImage ?
                e('button', { onClick: () => refImageInputRef.current?.click(), className: 'w-full py-4 border-2 border-dashed border-gray-300 rounded-lg hover:border-amber-500 flex flex-col items-center gap-1 text-gray-400' },
                  e(UploadIcon),
                  e('span', { className: 'text-xs' }, 'Upload')
                ) :
                e('div', { className: 'space-y-2' },
                  e('img', { src: refImage, alt: 'Preview', className: 'w-full rounded-lg border border-gray-300' }),
                  e('div', { className: 'flex gap-1' },
                    e('button', { onClick: () => setShowRefImage(!showRefImage), className: 'flex-1 p-2 rounded border border-gray-300 text-gray-600' }, showRefImage ? e(EyeIcon) : e(EyeOffIcon)),
                    e('button', { onClick: () => setRefImageLocked(!refImageLocked), className: `flex-1 p-2 rounded border ${refImageLocked ? 'border-amber-300 bg-amber-50 text-amber-600' : 'border-gray-300 text-gray-600'}` }, refImageLocked ? e(LockIcon) : e(UnlockIcon)),
                    e('button', { onClick: startCropping, className: 'flex-1 p-2 rounded border border-gray-300 text-gray-600' }, e(CropIcon)),
                    e('button', { onClick: () => { setRefImage(null); setOriginalImageData(null); }, className: 'flex-1 p-2 rounded border border-gray-300 text-red-500' }, e(XIcon))
                  ),
                  e('button', { 
                    onClick: () => setIsPositioningImage(true), 
                    className: 'w-full py-2 mt-1 rounded border border-green-300 text-green-600 text-sm flex items-center justify-center gap-1 hover:bg-green-50' 
                  }, e(MoveIcon), 'Position Image')
                )
            ),

            // Show/Hide Canvas
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Canvas Visibility'),
              e('button', { 
                onClick: () => setShowCanvas(!showCanvas), 
                className: `w-full py-2 px-3 rounded-lg border flex items-center justify-center gap-2 ${showCanvas ? 'border-gray-300 text-gray-600' : 'border-amber-400 bg-amber-50 text-amber-600'}` 
              },
                showCanvas ? e(EyeIcon) : e(EyeOffIcon),
                e('span', { className: 'text-sm' }, showCanvas ? 'Hide Canvas' : 'Show Canvas')
              )
            ),

            // Color Counts
            grid && e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, `Color Counts (${colorCount}/${MAX_COLORS})`),
              colorCount > MAX_COLORS && e('p', { className: 'text-xs text-red-500 mb-2' }, '⚠️ Too many colors!'),
              e('div', { className: 'space-y-1 max-h-48 overflow-y-auto' },
                PALETTE_ORDER.filter(name => usedColors[name] > 0).map(name =>
                  e('div', { key: name, className: 'flex items-center gap-2 text-xs' },
                    e('div', { className: 'w-4 h-4 rounded border border-gray-300', style: { backgroundColor: PALETTE[name].hex } }),
                    e('span', { className: 'flex-1 truncate' }, name),
                    e('span', { className: 'font-mono text-gray-600' }, usedColors[name])
                  )
                )
              )
            )
          ),

          // Mobile bottom sheet panels
          isMobile && activePanel && e('div', { 
            className: 'fixed inset-x-0 bg-white border-t border-gray-200 rounded-t-2xl shadow-lg z-40 bottom-sheet',
            style: { bottom: 56, maxHeight: '60vh', overflow: 'hidden', display: 'flex', flexDirection: 'column' }
          },
            e('div', { className: 'bg-white border-b border-gray-100 p-2 flex justify-between items-center shrink-0', style: { zIndex: 1 } },
              e('span', { className: 'font-semibold text-sm text-gray-700 px-2' }, 
                activePanel === 'settings' ? 'Settings' : activePanel === 'colors' ? 'Colors & Brush' : 'Reference Image'
              ),
              e('button', { onClick: () => setActivePanel(null), className: 'p-2 text-gray-500' }, e(XIcon))
            ),
            e('div', { className: 'p-3 overflow-y-auto flex-1' },
              // Settings panel
              activePanel === 'settings' && e('div', { className: 'space-y-4' },
                // Undo/Redo
                e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'History'),
                  e('div', { className: 'flex gap-2' },
                    e('button', { onClick: undo, disabled: historyIndex <= 0, className: 'flex-1 py-3 bg-gray-100 rounded-lg border border-gray-300 flex items-center justify-center gap-2 disabled:opacity-30' }, e(UndoIcon), 'Undo'),
                    e('button', { onClick: redo, disabled: historyIndex >= history.length - 1, className: 'flex-1 py-3 bg-gray-100 rounded-lg border border-gray-300 flex items-center justify-center gap-2 disabled:opacity-30' }, e(RedoIcon), 'Redo')
                  )
                ),
                // Grid setup
                e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Grid Setup'),
                  e('select', { value: canvasCount, onChange: (ev) => setCanvasCount(Number(ev.target.value)), className: 'w-full px-3 py-2 bg-gray-100 border border-gray-300 rounded-lg text-sm mb-2' },
                    e('option', { value: 13 }, '13 count'),
                    e('option', { value: 15 }, '15 count')
                  ),
                  e('div', { className: 'grid grid-cols-2 gap-2 mb-2' },
                    e('input', { type: 'number', value: gridWidth, onChange: (ev) => setGridWidth(ev.target.value), placeholder: 'Width', className: 'px-3 py-2 bg-gray-100 border border-gray-300 rounded-lg text-sm', min: 0, max: maxCrosses }),
                    e('input', { type: 'number', value: gridHeight, onChange: (ev) => setGridHeight(ev.target.value), placeholder: 'Height', className: 'px-3 py-2 bg-gray-100 border border-gray-300 rounded-lg text-sm', min: 0, max: maxCrosses })
                  ),
                  e('button', { onClick: createGrid, disabled: parsedWidth < 1 || parsedHeight < 1, className: 'w-full py-3 bg-amber-500 hover:bg-amber-600 disabled:bg-gray-300 rounded-lg text-sm font-medium text-white' }, grid ? 'Reset Grid' : 'Create Grid')
                ),
                // Size adjust
                grid && e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, `Adjust Size (${grid[0].length}×${grid.length})`),
                  e('p', { className: 'text-sm text-gray-600 mb-2' }, `${(grid[0].length / crossesPerInch).toFixed(2)}" × ${(grid.length / crossesPerInch).toFixed(2)}"`),
                  e('div', { className: 'grid grid-cols-4 gap-2' },
                    e('button', { onClick: addRowTop, className: 'py-3 bg-green-100 rounded-lg border border-green-300 text-green-700 text-lg' }, '+↑'),
                    e('button', { onClick: addRowBottom, className: 'py-3 bg-green-100 rounded-lg border border-green-300 text-green-700 text-lg' }, '+↓'),
                    e('button', { onClick: removeRowTop, className: 'py-3 bg-red-100 rounded-lg border border-red-300 text-red-700 text-lg' }, '-↑'),
                    e('button', { onClick: removeRowBottom, className: 'py-3 bg-red-100 rounded-lg border border-red-300 text-red-700 text-lg' }, '-↓'),
                    e('button', { onClick: addColLeft, className: 'py-3 bg-green-100 rounded-lg border border-green-300 text-green-700 text-lg' }, '+←'),
                    e('button', { onClick: addColRight, className: 'py-3 bg-green-100 rounded-lg border border-green-300 text-green-700 text-lg' }, '+→'),
                    e('button', { onClick: removeColLeft, className: 'py-3 bg-red-100 rounded-lg border border-red-300 text-red-700 text-lg' }, '-←'),
                    e('button', { onClick: removeColRight, className: 'py-3 bg-red-100 rounded-lg border border-red-300 text-red-700 text-lg' }, '-→')
                  )
                ),
                // View
                e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'View'),
                  e('div', { className: 'flex items-center gap-2 mb-2' },
                    e('button', { onClick: () => setZoom(z => Math.max(0.2, z * 0.8)), className: 'p-3 bg-gray-100 rounded-lg border border-gray-300' }, e(ZoomOutIcon)),
                    e('span', { className: 'flex-1 text-center text-sm' }, Math.round(zoom * 100) + '%'),
                    e('button', { onClick: () => setZoom(z => Math.min(4, z * 1.25)), className: 'p-3 bg-gray-100 rounded-lg border border-gray-300' }, e(ZoomInIcon)),
                    e('button', { onClick: () => { setZoom(1); setPan({ x: 0, y: 0 }); }, className: 'p-3 bg-gray-100 rounded-lg border border-gray-300' }, e(HomeIcon))
                  ),
                  e('div', null,
                    e('span', { className: 'text-xs text-gray-500' }, `Canvas Opacity: ${Math.round(canvasOpacity * 100)}%`),
                    e('input', { type: 'range', min: 0.1, max: 1, step: 0.05, value: canvasOpacity, onChange: (ev) => setCanvasOpacity(parseFloat(ev.target.value)), className: 'w-full mt-1' })
                  )
                )
              ),
              
              // Colors panel
              activePanel === 'colors' && e('div', { className: 'space-y-4' },
                e('div', { className: 'grid grid-cols-6 gap-2' },
                  PALETTE_ORDER.map(name =>
                    e('button', {
                      key: name,
                      onClick: () => setSelectedColor(name),
                      className: `aspect-square rounded-xl border-3 relative ${selectedColor === name ? 'border-amber-500 scale-105 shadow-md' : 'border-gray-300'}`,
                      style: { backgroundColor: PALETTE[name].hex, minHeight: 44 }
                    })
                  )
                ),
                e('div', { className: 'flex items-center gap-3 bg-gray-100 rounded-lg p-3' },
                  e('div', { className: 'w-12 h-12 rounded-lg border-2 border-gray-300', style: { backgroundColor: PALETTE[selectedColor].hex } }),
                  e('span', { className: 'font-medium' }, selectedColor)
                ),
                e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Brush Size'),
                  e('div', { className: 'flex items-center gap-3' },
                    e('span', { className: 'text-sm w-6' }, '1'),
                    e('input', { type: 'range', min: 1, max: 10, value: brushSize, onChange: (ev) => setBrushSize(parseInt(ev.target.value)), className: 'flex-1' }),
                    e('span', { className: 'text-sm w-6' }, '10')
                  ),
                  e('div', { className: 'mt-2 flex justify-center' },
                    e('div', { 
                      style: { 
                        width: Math.min(brushSize * 12, 60), 
                        height: Math.min(brushSize * 12, 60), 
                        borderRadius: '50%', 
                        backgroundColor: PALETTE[selectedColor].hex,
                        border: '2px solid #9ca3af'
                      } 
                    })
                  )
                ),
                // Color counts
                grid && e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, `Color Counts (${colorCount}/${MAX_COLORS})`),
                  colorCount > MAX_COLORS && e('p', { className: 'text-xs text-red-500 mb-2' }, '⚠️ Too many colors! Max 8 including white.'),
                  e('div', { className: 'space-y-1 max-h-32 overflow-y-auto' },
                    PALETTE_ORDER.filter(name => usedColors[name] > 0).map(name =>
                      e('div', { key: name, className: 'flex items-center gap-2 text-sm' },
                        e('div', { className: 'w-5 h-5 rounded border border-gray-300', style: { backgroundColor: PALETTE[name].hex } }),
                        e('span', { className: 'flex-1' }, name),
                        e('span', { className: 'font-mono text-gray-600' }, usedColors[name])
                      )
                    )
                  )
                )
              ),
              
              // Reference panel
              activePanel === 'reference' && e('div', { className: 'space-y-3' },
                e('input', { ref: refImageInputRef, type: 'file', accept: 'image/*', onChange: handleRefUpload, className: 'hidden' }),
                !refImage ?
                  e('button', { onClick: () => refImageInputRef.current?.click(), className: 'w-full py-8 border-2 border-dashed border-gray-300 rounded-xl flex flex-col items-center gap-2 text-gray-400' },
                    e(UploadIcon),
                    e('span', null, 'Upload Reference Image')
                  ) :
                  e('div', { className: 'space-y-3' },
                    e('img', { src: refImage, alt: 'Preview', className: 'w-full max-h-40 object-contain rounded-lg border border-gray-300' }),
                    e('div', { className: 'grid grid-cols-4 gap-2' },
                      e('button', { onClick: () => setShowRefImage(!showRefImage), className: `p-3 rounded-lg border ${showRefImage ? 'border-gray-300' : 'border-amber-300 bg-amber-50'}` }, showRefImage ? e(EyeIcon) : e(EyeOffIcon)),
                      e('button', { onClick: () => setRefImageLocked(!refImageLocked), className: `p-3 rounded-lg border ${refImageLocked ? 'border-amber-300 bg-amber-50' : 'border-gray-300'}` }, refImageLocked ? e(LockIcon) : e(UnlockIcon)),
                      e('button', { onClick: () => { startCropping(); setActivePanel(null); }, className: 'p-3 rounded-lg border border-gray-300' }, e(CropIcon)),
                      e('button', { onClick: () => { setRefImage(null); setOriginalImageData(null); }, className: 'p-3 rounded-lg border border-red-300 text-red-500' }, e(XIcon))
                    ),
                    e('button', { 
                      onClick: () => { setIsPositioningImage(true); setActivePanel(null); }, 
                      className: 'w-full py-3 rounded-lg border border-green-300 text-green-600 flex items-center justify-center gap-2 hover:bg-green-50' 
                    }, e(MoveIcon), 'Position Image')
                  )
              )
            )
          )
        ),

        // Spacer for fixed mobile nav
        isMobile && e('div', { style: { height: 56, flexShrink: 0 } }),

        // Mobile bottom toolbar - fixed at bottom
        isMobile && e('nav', { 
          style: { 
            position: 'fixed', 
            bottom: 0, 
            left: 0, 
            right: 0, 
            background: 'white', 
            borderTop: '1px solid #e5e7eb', 
            display: 'flex', 
            zIndex: 50, 
            minHeight: 56 
          }
        },
          e(TabButton, { icon: e(SettingsIcon), label: 'Settings', active: activePanel === 'settings', onClick: () => setActivePanel(activePanel === 'settings' ? null : 'settings') }),
          e(TabButton, { icon: e(PaletteIcon), label: 'Colors', active: activePanel === 'colors', onClick: () => setActivePanel(activePanel === 'colors' ? null : 'colors') }),
          e(TabButton, { icon: e(ImageIcon), label: 'Reference', active: activePanel === 'reference', onClick: () => setActivePanel(activePanel === 'reference' ? null : 'reference') }),
          e('button', { 
            onClick: () => setPanOnly(!panOnly), 
            className: `flex-1 flex flex-col items-center justify-center py-2 px-1 ${panOnly ? 'text-white bg-blue-500' : 'text-gray-600'}` 
          },
            e(MoveIcon),
            e('span', { className: 'text-[10px] mt-0.5' }, 'Move')
          ),
          e('button', { 
            onClick: () => setShowCanvas(!showCanvas), 
            className: `flex-1 flex flex-col items-center justify-center py-2 px-1 ${!showCanvas ? 'text-amber-500 bg-amber-50' : 'text-gray-600'}` 
          },
            showCanvas ? e(EyeIcon) : e(EyeOffIcon),
            e('span', { className: 'text-[10px] mt-0.5' }, showCanvas ? 'Hide' : 'Show')
          )
        ),

        // Download Menu Modal
        showDownloadMenu && e('div', {
          className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50',
          onClick: (ev) => { if (ev.target === ev.currentTarget) setShowDownloadMenu(false); }
        },
          e('div', { className: 'bg-white rounded-2xl p-6 mx-4 max-w-sm w-full shadow-xl' },
            e('div', { className: 'flex justify-between items-center mb-4' },
              e('h2', { className: 'text-xl font-bold text-gray-800' }, 'Download Options'),
              e('button', { onClick: () => setShowDownloadMenu(false), className: 'p-1 text-gray-500 hover:text-gray-700' }, e(XIcon))
            ),
            e('div', { className: 'space-y-3' },
              e('button', {
                onClick: generateStitchGuidePDF,
                className: 'w-full py-4 px-4 bg-gradient-to-r from-blue-400 to-blue-500 hover:from-blue-500 hover:to-blue-600 text-white rounded-xl font-medium flex items-center justify-center gap-3 shadow-lg'
              },
                e(DownloadIcon),
                e('span', null, 'Download Free Stitch Guide')
              ),
              e('button', {
                onClick: exportJSON,
                className: 'w-full py-4 px-4 bg-gradient-to-r from-amber-400 to-amber-500 hover:from-amber-500 hover:to-amber-600 text-white rounded-xl font-medium flex items-center justify-center gap-3 shadow-lg'
              },
                e('span', { className: 'text-lg' }, '💰'),
                e('span', null, 'Have Us Make It ($ XX)')
              )
            ),
            e('p', { className: 'text-xs text-gray-500 text-center mt-4' }, 
              'The stitch guide includes color patterns, symbol charts, and thread estimates.'
            )
          )
        ),

        // Saved Designs Menu Modal
        showSavedMenu && e('div', {
          className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50',
          onClick: (ev) => { if (ev.target === ev.currentTarget) setShowSavedMenu(false); }
        },
          e('div', { className: 'bg-white rounded-2xl p-6 mx-4 max-w-md w-full shadow-xl max-h-[80vh] flex flex-col' },
            e('div', { className: 'flex justify-between items-center mb-4 shrink-0' },
              e('h2', { className: 'text-xl font-bold text-gray-800 flex items-center gap-2' }, e(FolderIcon), 'Saved Designs'),
              e('button', { onClick: () => setShowSavedMenu(false), className: 'p-1 text-gray-500 hover:text-gray-700' }, e(XIcon))
            ),
            e('div', { className: 'flex-1 overflow-y-auto' },
              savedDesigns.length === 0 ? 
                e('div', { className: 'text-center py-8 text-gray-400' },
                  e('p', null, 'No saved designs yet.'),
                  e('p', { className: 'text-sm mt-2' }, 'Create a design and click Save to store it.')
                ) :
                e('div', { className: 'space-y-2' },
                  savedDesigns.map(design =>
                    e('div', { key: design.id, className: 'flex items-center gap-3 p-3 bg-gray-50 rounded-lg hover:bg-gray-100' },
                      e('div', { className: 'w-10 h-10 bg-amber-100 rounded-lg flex items-center justify-center text-amber-600' }, e(GridIcon)),
                      e('div', { className: 'flex-1 min-w-0' },
                        e('p', { className: 'font-medium truncate' }, design.name),
                        e('p', { className: 'text-xs text-gray-500' }, `${design.gridWidth}×${design.gridHeight} • ${design.canvasCount}ct`)
                      ),
                      e('button', { 
                        onClick: () => loadDesign(design), 
                        className: 'px-3 py-1.5 bg-amber-500 hover:bg-amber-600 text-white rounded-lg text-sm font-medium'
                      }, 'Load'),
                      e('button', { 
                        onClick: () => { if(confirm('Delete this design?')) deleteDesign(design.id); }, 
                        className: 'p-1.5 text-red-500 hover:bg-red-50 rounded'
                      }, e(TrashIcon))
                    )
                  )
                )
            ),
            e('div', { className: 'mt-4 pt-4 border-t border-gray-200 shrink-0' },
              e('button', { 
                onClick: () => { setShowSavedMenu(false); },
                className: 'w-full py-2 text-gray-600 hover:text-gray-800 text-sm'
              }, 'Close')
            )
          )
        ),

        // Color Warning Modal
        showColorWarning && e('div', {
          className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50',
          onClick: (ev) => { if (ev.target === ev.currentTarget) setShowColorWarning(false); }
        },
          e('div', { className: 'bg-white rounded-2xl p-6 mx-4 max-w-sm w-full shadow-xl' },
            e('div', { className: 'text-center' },
              e('div', { className: 'w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4' },
                e('span', { className: 'text-3xl' }, '⚠️')
              ),
              e('h2', { className: 'text-xl font-bold text-gray-800 mb-2' }, 'Too Many Colors!'),
              e('p', { className: 'text-gray-600 mb-4' }, 
                `You're using ${colorCount} colors. For best results, please limit your design to ${MAX_COLORS} colors (including white).`
              ),
              e('p', { className: 'text-sm text-gray-500 mb-6' }, 
                'More colors increase complexity and cost of the final needlepoint.'
              ),
              e('button', { 
                onClick: () => setShowColorWarning(false), 
                className: 'w-full py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-xl font-medium'
              }, 'Got it!')
            )
          )
        ),

        // Brush cursor (desktop only)
        !isMobile && showBrushCursor && brushSize > 1 && e('div', {
          style: {
            position: 'fixed',
            left: mousePos.x, top: mousePos.y,
            width: brushSize * cellSize * zoom,
            height: brushSize * cellSize * zoom,
            border: '2px solid ' + PALETTE[selectedColor].hex,
            borderRadius: '50%',
            pointerEvents: 'none',
            transform: 'translate(-50%, -50%)',
            zIndex: 1000,
            boxShadow: '0 0 0 1px rgba(255,255,255,0.8), inset 0 0 0 1px rgba(255,255,255,0.8)'
          }
        })
      );
    }

    ReactDOM.render(React.createElement(App), document.getElementById('root'));
  </script>
</body>
</html>
