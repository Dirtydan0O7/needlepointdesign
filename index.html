<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Needlepoint Designer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body, #root { height: 100%; width: 100%; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #fafafa; overflow: hidden; touch-action: none; }
    .grid-cell { transition: none; }
    input[type="range"] { -webkit-appearance: none; background: #e5e5e5; height: 8px; border-radius: 4px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 24px; height: 24px; background: #f59e0b; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    input[type="number"]::-webkit-inner-spin-button { opacity: 1; }
    .crop-handle { position: absolute; background: #f59e0b; border: 2px solid white; border-radius: 4px; }
    .bottom-sheet { transition: transform 0.3s ease-out; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    const { useState, useRef, useCallback, useEffect } = React;

    const PALETTE = {
      'Red': { hex: '#ed2415' },
      'Orange': { hex: '#ff9a03' },
      'Yellow': { hex: '#fcfc03' },
      'LimeGreen': { hex: '#1cfc03' },
      'DarkGreen': { hex: '#2ca11f' },
      'Brown': { hex: '#a66f17' },
      'Cream': { hex: '#e0af60' },
      'Black': { hex: '#000000' },
      'White': { hex: '#ffffff' },
      'Blue': { hex: '#2b98e0' },
      'Pink': { hex: '#db9ad5' },
      'Gray': { hex: '#969696' },
    };

    const PALETTE_ORDER = ['White', 'Black', 'Gray', 'Red', 'Orange', 'Yellow', 'LimeGreen', 'DarkGreen', 'Blue', 'Pink', 'Brown', 'Cream'];
    const MAX_CROSSES = { 13: 110, 15: 127 };

    function App() {
      const [designName, setDesignName] = useState('MyDesign');
      const [canvasCount, setCanvasCount] = useState(13);
      const [grid, setGrid] = useState(null);
      const [selectedColor, setSelectedColor] = useState('Black');
      const [gridWidth, setGridWidth] = useState('26');
      const [gridHeight, setGridHeight] = useState('26');
      const [canvasOpacity, setCanvasOpacity] = useState(0.5);
      const [showCanvas, setShowCanvas] = useState(true);
      const [refImage, setRefImage] = useState(null);
      const [refImageSize, setRefImageSize] = useState({ width: 300, height: 300 });
      const [refImagePosition, setRefImagePosition] = useState({ x: 20, y: 20 });
      const [refImageLocked, setRefImageLocked] = useState(false);
      const [showRefImage, setShowRefImage] = useState(true);
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);
      const [isPainting, setIsPainting] = useState(false);
      const [isDraggingImage, setIsDraggingImage] = useState(false);
      const [isResizingImage, setIsResizingImage] = useState(false);
      const [brushSize, setBrushSize] = useState(1);
      const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
      const [showBrushCursor, setShowBrushCursor] = useState(false);
      
      // Mobile panels
      const [activePanel, setActivePanel] = useState(null); // 'settings', 'colors', 'reference'
      const [showMobileMenu, setShowMobileMenu] = useState(false);
      const [isMobile, setIsMobile] = useState(window.innerWidth < 769);
      
      // Update isMobile on resize
      useEffect(() => {
        const handleResize = () => setIsMobile(window.innerWidth < 769);
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);
      
      // Cropping state
      const [isCropping, setIsCropping] = useState(false);
      const [cropBox, setCropBox] = useState({ x: 0, y: 0, w: 100, h: 100 });
      const [isDraggingCrop, setIsDraggingCrop] = useState(false);
      const [cropDragType, setCropDragType] = useState(null);
      const [originalImageData, setOriginalImageData] = useState(null);
      
      // Pan and Zoom
      const [zoom, setZoom] = useState(1);
      const [pan, setPan] = useState({ x: 0, y: 0 });
      const [isPanning, setIsPanning] = useState(false);
      const [gridOffset, setGridOffset] = useState({ x: 0, y: 0 });
      
      // Touch state
      const [touchMode, setTouchMode] = useState(null); // 'paint', 'pan', 'pinch'
      const lastTouchRef = useRef(null);

      const refImageInputRef = useRef(null);
      const workspaceRef = useRef(null);
      const contentRef = useRef(null);
      const gridRef = useRef(null);
      const panStartRef = useRef({ x: 0, y: 0, panX: 0, panY: 0 });
      const imgDragStartRef = useRef({ x: 0, y: 0, imgX: 0, imgY: 0 });
      const imgResizeStartRef = useRef({ w: 0, h: 0, x: 0, y: 0 });
      const pinchStartRef = useRef({ distance: 0, zoom: 1, panX: 0, panY: 0, centerX: 0, centerY: 0 });
      const cropStartRef = useRef({ x: 0, y: 0, box: null });

      const cellSize = 18;
      const crossesPerInch = canvasCount;
      const maxCrosses = MAX_CROSSES[canvasCount];
      const parsedWidth = gridWidth === '' ? 0 : parseInt(gridWidth) || 0;
      const parsedHeight = gridHeight === '' ? 0 : parseInt(gridHeight) || 0;

      const getUsedColors = useCallback(() => {
        if (!grid) return {};
        const counts = {};
        grid.forEach(row => row.forEach(color => {
          counts[color] = (counts[color] || 0) + 1;
        }));
        return counts;
      }, [grid]);

      const usedColors = getUsedColors();

      const saveHistory = useCallback((newGrid) => {
        setHistory(prev => {
          const h = prev.slice(0, historyIndex + 1);
          h.push(JSON.stringify(newGrid));
          return h.slice(-50);
        });
        setHistoryIndex(prev => Math.min(prev + 1, 49));
      }, [historyIndex]);

      const createGrid = () => {
        const w = Math.min(parsedWidth, maxCrosses);
        const h = Math.min(parsedHeight, maxCrosses);
        if (w < 1 || h < 1) return;
        const newGrid = Array(h).fill(null).map(() => Array(w).fill('White'));
        setGrid(newGrid);
        setHistory([JSON.stringify(newGrid)]);
        setHistoryIndex(0);
        setPan({ x: 0, y: 0 });
        setZoom(1);
        setGridOffset({ x: 0, y: 0 });
        setActivePanel(null);
      };

      const undo = () => {
        if (historyIndex > 0) {
          setHistoryIndex(historyIndex - 1);
          setGrid(JSON.parse(history[historyIndex - 1]));
        }
      };

      const redo = () => {
        if (historyIndex < history.length - 1) {
          setHistoryIndex(historyIndex + 1);
          setGrid(JSON.parse(history[historyIndex + 1]));
        }
      };

      const addRowTop = () => {
        if (!grid || grid.length >= maxCrosses) return;
        const newRow = Array(grid[0].length).fill('White');
        const newGrid = [newRow, ...grid];
        setGrid(newGrid);
        setGridHeight(String(newGrid.length));
        setGridOffset(o => ({ x: o.x, y: o.y - cellSize }));
        saveHistory(newGrid);
      };

      const addRowBottom = () => {
        if (!grid || grid.length >= maxCrosses) return;
        const newRow = Array(grid[0].length).fill('White');
        const newGrid = [...grid, newRow];
        setGrid(newGrid);
        setGridHeight(String(newGrid.length));
        saveHistory(newGrid);
      };

      const removeRowTop = () => {
        if (!grid || grid.length <= 1) return;
        const newGrid = grid.slice(1);
        setGrid(newGrid);
        setGridHeight(String(newGrid.length));
        setGridOffset(o => ({ x: o.x, y: o.y + cellSize }));
        saveHistory(newGrid);
      };

      const removeRowBottom = () => {
        if (!grid || grid.length <= 1) return;
        const newGrid = grid.slice(0, -1);
        setGrid(newGrid);
        setGridHeight(String(newGrid.length));
        saveHistory(newGrid);
      };

      const addColLeft = () => {
        if (!grid || grid[0].length >= maxCrosses) return;
        const newGrid = grid.map(row => ['White', ...row]);
        setGrid(newGrid);
        setGridWidth(String(newGrid[0].length));
        setGridOffset(o => ({ x: o.x - cellSize, y: o.y }));
        saveHistory(newGrid);
      };

      const addColRight = () => {
        if (!grid || grid[0].length >= maxCrosses) return;
        const newGrid = grid.map(row => [...row, 'White']);
        setGrid(newGrid);
        setGridWidth(String(newGrid[0].length));
        saveHistory(newGrid);
      };

      const removeColLeft = () => {
        if (!grid || grid[0].length <= 1) return;
        const newGrid = grid.map(row => row.slice(1));
        setGrid(newGrid);
        setGridWidth(String(newGrid[0].length));
        setGridOffset(o => ({ x: o.x + cellSize, y: o.y }));
        saveHistory(newGrid);
      };

      const removeColRight = () => {
        if (!grid || grid[0].length <= 1) return;
        const newGrid = grid.map(row => row.slice(0, -1));
        setGrid(newGrid);
        setGridWidth(String(newGrid[0].length));
        saveHistory(newGrid);
      };

      const paintWithBrush = (centerX, centerY) => {
        if (!grid) return;
        const radius = brushSize - 1;
        const newGrid = grid.map((row, y) => 
          row.map((cell, x) => {
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance <= radius + 0.5) {
              return selectedColor;
            }
            return cell;
          })
        );
        setGrid(newGrid);
      };

      const fillRegion = (startX, startY) => {
        if (!grid) return;
        const target = grid[startY][startX];
        if (target === selectedColor) return;
        const newGrid = grid.map(r => [...r]);
        const stack = [[startX, startY]];
        const visited = new Set();
        while (stack.length) {
          const [x, y] = stack.pop();
          const key = x + ',' + y;
          if (visited.has(key) || x < 0 || x >= grid[0].length || y < 0 || y >= grid.length) continue;
          if (newGrid[y][x] !== target) continue;
          visited.add(key);
          newGrid[y][x] = selectedColor;
          stack.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
        }
        setGrid(newGrid);
        saveHistory(newGrid);
      };

      const handleRefUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const img = new Image();
          img.onload = () => {
            const scale = Math.min(300 / img.width, 300 / img.height, 1);
            setRefImageSize({ width: img.width * scale, height: img.height * scale });
            setRefImage(ev.target.result);
            setOriginalImageData(ev.target.result);
            setRefImagePosition({ x: 50, y: 50 });
            setCropBox({ x: 0, y: 0, w: img.width * scale, h: img.height * scale });
          };
          img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      };

      const startCropping = () => {
        setIsCropping(true);
        setCropBox({ x: 0, y: 0, w: refImageSize.width, h: refImageSize.height });
        setActivePanel(null);
      };

      const applyCrop = () => {
        if (!originalImageData) return;
        const img = new Image();
        img.onload = () => {
          const scaleX = img.width / refImageSize.width;
          const scaleY = img.height / refImageSize.height;
          const canvas = document.createElement('canvas');
          canvas.width = cropBox.w * scaleX;
          canvas.height = cropBox.h * scaleY;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, cropBox.x * scaleX, cropBox.y * scaleY, cropBox.w * scaleX, cropBox.h * scaleY, 0, 0, canvas.width, canvas.height);
          const croppedData = canvas.toDataURL('image/png');
          setRefImage(croppedData);
          setOriginalImageData(croppedData);
          setRefImageSize({ width: cropBox.w, height: cropBox.h });
          setIsCropping(false);
        };
        img.src = originalImageData;
      };

      const cancelCrop = () => {
        setIsCropping(false);
      };

      const exportDesign = () => {
        if (!grid) return;
        const data = {
          version: "2.0",
          design_name: designName,
          canvas_count: canvasCount,
          crosses_per_inch: crossesPerInch,
          design_width_crosses: grid[0].length,
          design_height_crosses: grid.length,
          design_width_inches: (grid[0].length / crossesPerInch).toFixed(2),
          design_height_inches: (grid.length / crossesPerInch).toFixed(2),
          colors_used: Object.keys(usedColors).filter(c => usedColors[c] > 0),
          color_counts: usedColors,
          palette: PALETTE,
          grid: grid,
          created_at: new Date().toISOString(),
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = designName + '_needlepoint.json';
        a.click();
        URL.revokeObjectURL(url);
      };

      const getTouchDistance = (t1, t2) => {
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      };

      const getTouchCenter = (t1, t2) => ({
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      });

      // Wheel zoom
      const handleWheel = useCallback((e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.975 : 1.025;
        
        const rect = workspaceRef.current.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const contentX = (mouseX - pan.x - 100) / zoom;
        const contentY = (mouseY - pan.y - 100) / zoom;
        
        const newZoom = Math.min(4, Math.max(0.2, zoom * delta));
        
        const newPanX = mouseX - 100 - contentX * newZoom;
        const newPanY = mouseY - 100 - contentY * newZoom;
        
        setZoom(newZoom);
        setPan({ x: newPanX, y: newPanY });
      }, [zoom, pan]);

      // Touch handlers
      const handleTouchStart = useCallback((e) => {
        if (e.touches.length === 2) {
          // Pinch zoom
          e.preventDefault();
          const dist = getTouchDistance(e.touches[0], e.touches[1]);
          const center = getTouchCenter(e.touches[0], e.touches[1]);
          pinchStartRef.current = { 
            distance: dist, 
            zoom: zoom,
            panX: pan.x,
            panY: pan.y,
            centerX: center.x,
            centerY: center.y
          };
          setTouchMode('pinch');
        } else if (e.touches.length === 1) {
          const target = e.target;
          
          // Check if touching a grid cell - let cell handle it for painting
          if (target.classList.contains('grid-cell')) {
            setTouchMode('paint');
            return; // Don't prevent default, let the cell handlers work
          }
          
          const isWorkspace = target === workspaceRef.current || 
                             target === contentRef.current || 
                             target.classList.contains('workspace-bg');
          
          if (isWorkspace) {
            // Pan with single finger on empty space
            setTouchMode('pan');
            panStartRef.current = { 
              x: e.touches[0].clientX, 
              y: e.touches[0].clientY, 
              panX: pan.x, 
              panY: pan.y 
            };
          }
          lastTouchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      }, [zoom, pan]);

      const handleTouchMove = useCallback((e) => {
        if (touchMode === 'pinch' && e.touches.length === 2) {
          e.preventDefault();
          const dist = getTouchDistance(e.touches[0], e.touches[1]);
          const center = getTouchCenter(e.touches[0], e.touches[1]);
          
          const scale = dist / pinchStartRef.current.distance;
          const newZoom = Math.min(4, Math.max(0.2, pinchStartRef.current.zoom * scale));
          
          // Pan while pinching
          const dx = center.x - pinchStartRef.current.centerX;
          const dy = center.y - pinchStartRef.current.centerY;
          
          setZoom(newZoom);
          setPan({ 
            x: pinchStartRef.current.panX + dx, 
            y: pinchStartRef.current.panY + dy 
          });
        } else if (touchMode === 'pan' && e.touches.length === 1) {
          const dx = e.touches[0].clientX - panStartRef.current.x;
          const dy = e.touches[0].clientY - panStartRef.current.y;
          setPan({ 
            x: panStartRef.current.panX + dx, 
            y: panStartRef.current.panY + dy 
          });
        } else if (touchMode === 'paint' && e.touches.length === 1) {
          // Let the grid cell handlers manage painting
          // Just track position for reference
          lastTouchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          return; // Don't prevent any default behavior
        }
        
        if (e.touches.length === 1) {
          lastTouchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      }, [touchMode]);

      const handleTouchEnd = useCallback((e) => {
        if (e.touches.length === 0) {
          if (isPainting && grid) saveHistory(grid);
          setIsPainting(false);
          setTouchMode(null);
        } else if (e.touches.length === 1) {
          // Switched from pinch to single finger - start pan
          setTouchMode('pan');
          panStartRef.current = { 
            x: e.touches[0].clientX, 
            y: e.touches[0].clientY, 
            panX: pan.x, 
            panY: pan.y 
          };
        }
      }, [isPainting, grid, saveHistory, pan]);

      // Mouse handlers for desktop
      const handleMouseDown = (e) => {
        const isWorkspace = e.target === workspaceRef.current || 
                           e.target === contentRef.current || 
                           e.target.classList.contains('workspace-bg');
        if (isWorkspace) {
          e.preventDefault();
          setIsPanning(true);
          panStartRef.current = { x: e.clientX, y: e.clientY, panX: pan.x, panY: pan.y };
        }
      };

      const handleMouseMove = useCallback((e) => {
        if (isPanning && !isDraggingImage && !isResizingImage && !isDraggingCrop) {
          const dx = e.clientX - panStartRef.current.x;
          const dy = e.clientY - panStartRef.current.y;
          setPan({ x: panStartRef.current.panX + dx, y: panStartRef.current.panY + dy });
        }
        if (isDraggingImage && !refImageLocked) {
          const dx = (e.clientX - imgDragStartRef.current.x) / zoom;
          const dy = (e.clientY - imgDragStartRef.current.y) / zoom;
          setRefImagePosition({ x: imgDragStartRef.current.imgX + dx, y: imgDragStartRef.current.imgY + dy });
        }
        if (isResizingImage && !refImageLocked) {
          const dx = (e.clientX - imgResizeStartRef.current.x) / zoom;
          const dy = (e.clientY - imgResizeStartRef.current.y) / zoom;
          setRefImageSize({ width: Math.max(50, imgResizeStartRef.current.w + dx), height: Math.max(50, imgResizeStartRef.current.h + dy) });
        }
        if (isDraggingCrop && cropDragType) {
          const dx = (e.clientX - cropStartRef.current.x) / zoom;
          const dy = (e.clientY - cropStartRef.current.y) / zoom;
          const box = cropStartRef.current.box;
          
          let newBox = { ...cropBox };
          
          if (cropDragType === 'move') {
            newBox.x = Math.max(0, Math.min(refImageSize.width - box.w, box.x + dx));
            newBox.y = Math.max(0, Math.min(refImageSize.height - box.h, box.y + dy));
          } else if (cropDragType === 'nw') {
            const newX = Math.max(0, Math.min(box.x + box.w - 20, box.x + dx));
            const newY = Math.max(0, Math.min(box.y + box.h - 20, box.y + dy));
            newBox = { x: newX, y: newY, w: box.x + box.w - newX, h: box.y + box.h - newY };
          } else if (cropDragType === 'ne') {
            const newW = Math.max(20, Math.min(refImageSize.width - box.x, box.w + dx));
            const newY = Math.max(0, Math.min(box.y + box.h - 20, box.y + dy));
            newBox = { x: box.x, y: newY, w: newW, h: box.y + box.h - newY };
          } else if (cropDragType === 'sw') {
            const newX = Math.max(0, Math.min(box.x + box.w - 20, box.x + dx));
            const newH = Math.max(20, Math.min(refImageSize.height - box.y, box.h + dy));
            newBox = { x: newX, y: box.y, w: box.x + box.w - newX, h: newH };
          } else if (cropDragType === 'se') {
            const newW = Math.max(20, Math.min(refImageSize.width - box.x, box.w + dx));
            const newH = Math.max(20, Math.min(refImageSize.height - box.y, box.h + dy));
            newBox = { x: box.x, y: box.y, w: newW, h: newH };
          }
          
          setCropBox(newBox);
        }
      }, [isPanning, isDraggingImage, isResizingImage, isDraggingCrop, cropDragType, zoom, refImageLocked, refImageSize, cropBox]);

      const handleMouseUp = useCallback(() => {
        if (isPainting && grid) saveHistory(grid);
        setIsPainting(false);
        setIsDraggingImage(false);
        setIsResizingImage(false);
        setIsPanning(false);
        setIsDraggingCrop(false);
        setCropDragType(null);
      }, [isPainting, grid, saveHistory]);

      useEffect(() => {
        const workspace = workspaceRef.current;
        if (workspace) {
          workspace.addEventListener('wheel', handleWheel, { passive: false });
          workspace.addEventListener('touchstart', handleTouchStart, { passive: false });
          workspace.addEventListener('touchmove', handleTouchMove, { passive: false });
          workspace.addEventListener('touchend', handleTouchEnd, { passive: false });
        }
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
        
        return () => {
          if (workspace) {
            workspace.removeEventListener('wheel', handleWheel);
            workspace.removeEventListener('touchstart', handleTouchStart);
            workspace.removeEventListener('touchmove', handleTouchMove);
            workspace.removeEventListener('touchend', handleTouchEnd);
          }
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('mouseup', handleMouseUp);
        };
      }, [handleWheel, handleTouchStart, handleTouchMove, handleTouchEnd, handleMouseMove, handleMouseUp]);

      // Grid touch painting - separate from workspace handlers
      useEffect(() => {
        const gridEl = gridRef.current;
        if (!gridEl || !grid) return;
        
        let painting = false;
        
        const getCellFromTouch = (touch) => {
          const rect = gridEl.getBoundingClientRect();
          const x = Math.floor((touch.clientX - rect.left) / (cellSize * zoom));
          const y = Math.floor((touch.clientY - rect.top) / (cellSize * zoom));
          if (x >= 0 && x < grid[0].length && y >= 0 && y < grid.length) {
            return { x, y };
          }
          return null;
        };
        
        const handleGridTouchStart = (e) => {
          if (e.touches.length === 1) {
            e.stopPropagation();
            painting = true;
            setIsPainting(true);
            const cell = getCellFromTouch(e.touches[0]);
            if (cell) paintWithBrush(cell.x, cell.y);
          }
        };
        
        const handleGridTouchMove = (e) => {
          if (e.touches.length === 1 && painting) {
            e.preventDefault();
            e.stopPropagation();
            const cell = getCellFromTouch(e.touches[0]);
            if (cell) paintWithBrush(cell.x, cell.y);
          }
        };
        
        const handleGridTouchEnd = (e) => {
          if (painting) {
            painting = false;
            if (grid) saveHistory(grid);
            setIsPainting(false);
          }
        };
        
        gridEl.addEventListener('touchstart', handleGridTouchStart, { passive: false });
        gridEl.addEventListener('touchmove', handleGridTouchMove, { passive: false });
        gridEl.addEventListener('touchend', handleGridTouchEnd, { passive: false });
        
        return () => {
          gridEl.removeEventListener('touchstart', handleGridTouchStart);
          gridEl.removeEventListener('touchmove', handleGridTouchMove);
          gridEl.removeEventListener('touchend', handleGridTouchEnd);
        };
      }, [grid, zoom, cellSize, selectedColor, brushSize, saveHistory, paintWithBrush]);

      // Keyboard shortcuts
      useEffect(() => {
        if (!isCropping) return;
        const handleKeyDown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            applyCrop();
          } else if (e.key === 'Escape') {
            e.preventDefault();
            cancelCrop();
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      });

      const e = React.createElement;

      // Icons (larger for touch)
      const Icon = ({ d, size = 20 }) => e('svg', { width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' }, e('path', { d }));
      const MenuIcon = () => Icon({ d: 'M3 12h18M3 6h18M3 18h18' });
      const GridIcon = () => Icon({ d: 'M3 3h7v7H3zM14 3h7v7h-7zM14 14h7v7h-7zM3 14h7v7H3z' });
      const DownloadIcon = () => Icon({ d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3' });
      const UndoIcon = () => Icon({ d: 'M3 7v6h6M3 13a9 9 0 1 0 2.5-6.5L3 7' });
      const RedoIcon = () => Icon({ d: 'M21 7v6h-6M21 13a9 9 0 1 1-2.5-6.5L21 7' });
      const ZoomInIcon = () => Icon({ d: 'M11 3a8 8 0 1 0 0 16 8 8 0 0 0 0-16zM21 21l-4.35-4.35M11 8v6M8 11h6' });
      const ZoomOutIcon = () => Icon({ d: 'M11 3a8 8 0 1 0 0 16 8 8 0 0 0 0-16zM21 21l-4.35-4.35M8 11h6' });
      const EyeIcon = () => Icon({ d: 'M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8zM12 9a3 3 0 1 0 0 6 3 3 0 0 0 0-6z' });
      const EyeOffIcon = () => Icon({ d: 'M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24M1 1l22 22' });
      const LockIcon = () => Icon({ d: 'M19 11H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2zM7 11V7a5 5 0 0 1 10 0v4' });
      const UnlockIcon = () => Icon({ d: 'M19 11H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2zM7 11V7a5 5 0 0 1 9.9-1' });
      const UploadIcon = () => Icon({ d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12' });
      const XIcon = () => Icon({ d: 'M18 6L6 18M6 6l12 12' });
      const CheckIcon = () => Icon({ d: 'M20 6L9 17l-5-5' });
      const SettingsIcon = () => Icon({ d: 'M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z' });
      const PaletteIcon = () => Icon({ d: 'M12 2a10 10 0 0 0-8.66 15 10 10 0 0 0 17.32 0A10 10 0 0 0 12 2zM12 12m-2 0a2 2 0 1 0 4 0 2 2 0 1 0-4 0' });
      const ImageIcon = () => Icon({ d: 'M5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2zM21 15l-5-5L5 21M8.5 10a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z' });
      const HomeIcon = () => Icon({ d: 'M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z' });
      const CropIcon = () => Icon({ d: 'M6 2v4H2v2h4v10h10v4h2v-4h4v-2H8V6h10v6h2V6a2 2 0 0 0-2-2H6V2' });
      const BrushIcon = () => Icon({ d: 'M9.06 11.9l8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08M9.06 11.9L5 22l10.1-4.06M9.06 11.9l4.03 4.03' });
      const PlusIcon = () => Icon({ d: 'M12 5v14M5 12h14' });
      const MinusIcon = () => Icon({ d: 'M5 12h14' });

      // Mobile bottom toolbar tab
      const TabButton = ({ icon, label, active, onClick }) => 
        e('button', { 
          onClick, 
          className: `flex-1 flex flex-col items-center justify-center py-2 px-1 ${active ? 'text-amber-500 bg-amber-50' : 'text-gray-600'}` 
        },
          icon,
          e('span', { className: 'text-[10px] mt-0.5' }, label)
        );

      return e('div', { className: 'h-screen bg-gray-50 text-gray-800 flex flex-col overflow-hidden' },
        // Header
        e('header', { className: 'bg-white border-b border-gray-200 py-2 px-3 flex items-center justify-between shrink-0 shadow-sm z-30' },
          e('div', { className: 'flex items-center gap-2' },
            e('div', { className: 'w-8 h-8 bg-amber-500 rounded-lg flex items-center justify-center text-white' }, e(GridIcon)),
            e('span', { className: 'font-bold text-sm hidden sm:block text-gray-800' }, 'Needlepoint'),
            e('input', { type: 'text', value: designName, onChange: (ev) => setDesignName(ev.target.value.replace(/[^a-zA-Z0-9]/g, '')), className: 'bg-gray-100 text-gray-800 px-2 py-1 rounded border border-gray-300 text-sm w-20 sm:w-28 focus:outline-none focus:border-amber-500' })
          ),
          e('div', { className: 'flex items-center gap-1' },
            // Undo/Redo
            e('button', { onClick: undo, disabled: historyIndex <= 0, className: 'p-2 rounded disabled:opacity-30 text-gray-600' }, e(UndoIcon)),
            e('button', { onClick: redo, disabled: historyIndex >= history.length - 1, className: 'p-2 rounded disabled:opacity-30 text-gray-600' }, e(RedoIcon)),
            // Export
            e('button', { onClick: exportDesign, disabled: !grid, className: 'p-2 bg-amber-500 hover:bg-amber-600 rounded disabled:opacity-50 text-white ml-1' }, e(DownloadIcon))
          )
        ),

        // Main area
        e('div', { className: 'flex flex-1 overflow-hidden relative' },
          // Desktop left sidebar
          !isMobile && e('aside', { className: 'w-52 bg-white border-r border-gray-200 p-3 overflow-y-auto shrink-0' },
            // Grid Setup
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Grid Setup'),
              e('div', { className: 'space-y-2' },
                e('select', { value: canvasCount, onChange: (ev) => setCanvasCount(Number(ev.target.value)), className: 'w-full px-2 py-1.5 bg-gray-100 border border-gray-300 rounded text-sm' },
                  e('option', { value: 13 }, '13 count'),
                  e('option', { value: 15 }, '15 count')
                ),
                e('div', { className: 'grid grid-cols-2 gap-2' },
                  e('div', null,
                    e('label', { className: 'text-xs text-gray-500' }, 'Width'),
                    e('input', { type: 'number', value: gridWidth, onChange: (ev) => setGridWidth(ev.target.value), className: 'w-full px-2 py-1 bg-gray-100 border border-gray-300 rounded text-sm', min: 0, max: maxCrosses })
                  ),
                  e('div', null,
                    e('label', { className: 'text-xs text-gray-500' }, 'Height'),
                    e('input', { type: 'number', value: gridHeight, onChange: (ev) => setGridHeight(ev.target.value), className: 'w-full px-2 py-1 bg-gray-100 border border-gray-300 rounded text-sm', min: 0, max: maxCrosses })
                  )
                ),
                e('p', { className: 'text-xs text-gray-500' }, `${(parsedWidth/crossesPerInch).toFixed(2)}" × ${(parsedHeight/crossesPerInch).toFixed(2)}"`),
                e('button', { onClick: createGrid, disabled: parsedWidth < 1 || parsedHeight < 1, className: 'w-full py-2 bg-amber-500 hover:bg-amber-600 disabled:bg-gray-300 rounded text-sm font-medium text-white' }, grid ? 'Reset Grid' : 'Create Grid')
              )
            ),

            // Size adjust (desktop)
            grid && e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Adjust Size'),
              e('div', { className: 'space-y-2 text-xs' },
                e('div', null,
                  e('span', { className: 'text-gray-500 block mb-1' }, 'Rows'),
                  e('div', { className: 'flex gap-1' },
                    e('button', { onClick: addRowTop, className: 'flex-1 py-1.5 bg-green-100 hover:bg-green-200 rounded border border-green-300 text-green-700' }, '+↑'),
                    e('button', { onClick: addRowBottom, className: 'flex-1 py-1.5 bg-green-100 hover:bg-green-200 rounded border border-green-300 text-green-700' }, '+↓'),
                    e('button', { onClick: removeRowTop, className: 'flex-1 py-1.5 bg-red-100 hover:bg-red-200 rounded border border-red-300 text-red-700' }, '-↑'),
                    e('button', { onClick: removeRowBottom, className: 'flex-1 py-1.5 bg-red-100 hover:bg-red-200 rounded border border-red-300 text-red-700' }, '-↓')
                  )
                ),
                e('div', null,
                  e('span', { className: 'text-gray-500 block mb-1' }, 'Columns'),
                  e('div', { className: 'flex gap-1' },
                    e('button', { onClick: addColLeft, className: 'flex-1 py-1.5 bg-green-100 hover:bg-green-200 rounded border border-green-300 text-green-700' }, '+←'),
                    e('button', { onClick: addColRight, className: 'flex-1 py-1.5 bg-green-100 hover:bg-green-200 rounded border border-green-300 text-green-700' }, '+→'),
                    e('button', { onClick: removeColLeft, className: 'flex-1 py-1.5 bg-red-100 hover:bg-red-200 rounded border border-red-300 text-red-700' }, '-←'),
                    e('button', { onClick: removeColRight, className: 'flex-1 py-1.5 bg-red-100 hover:bg-red-200 rounded border border-red-300 text-red-700' }, '-→')
                  )
                ),
                e('p', { className: 'text-gray-500 mt-1 text-center' }, `${grid[0].length} × ${grid.length}`)
              )
            ),

            // View controls (desktop)
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'View'),
              e('div', { className: 'space-y-2' },
                e('div', { className: 'flex items-center gap-1' },
                  e('button', { onClick: () => setZoom(z => Math.max(0.2, z * 0.8)), className: 'p-2 bg-gray-100 rounded border border-gray-300' }, e(ZoomOutIcon)),
                  e('span', { className: 'flex-1 text-xs text-center' }, Math.round(zoom * 100) + '%'),
                  e('button', { onClick: () => setZoom(z => Math.min(4, z * 1.25)), className: 'p-2 bg-gray-100 rounded border border-gray-300' }, e(ZoomInIcon))
                ),
                e('div', null,
                  e('div', { className: 'flex items-center justify-between mb-1' },
                    e('span', { className: 'text-xs text-gray-500' }, 'Opacity'),
                    e('span', { className: 'text-xs text-gray-400' }, Math.round(canvasOpacity * 100) + '%')
                  ),
                  e('input', { type: 'range', min: 0.1, max: 1, step: 0.05, value: canvasOpacity, onChange: (ev) => setCanvasOpacity(parseFloat(ev.target.value)), className: 'w-full' })
                ),
                e('button', { onClick: () => { setZoom(1); setPan({ x: 0, y: 0 }); }, className: 'w-full py-1.5 text-xs bg-gray-100 rounded border border-gray-300 flex items-center justify-center gap-1' }, e(HomeIcon), 'Reset View')
              )
            )
          ),

          // Workspace
          e('main', { 
            ref: workspaceRef,
            className: 'flex-1 overflow-hidden bg-gray-200 relative',
            style: { cursor: isPanning ? 'grabbing' : 'grab' },
            onMouseDown: handleMouseDown
          },
            // Background
            e('div', { 
              className: 'workspace-bg absolute',
              style: {
                width: '300%', height: '300%', left: '-100%', top: '-100%',
                backgroundImage: 'radial-gradient(circle, #d1d5db 1px, transparent 1px)',
                backgroundSize: `${20 * zoom}px ${20 * zoom}px`,
                transform: `translate(${pan.x}px, ${pan.y}px)`,
                pointerEvents: 'all'
              }
            }),
            
            // Content container
            e('div', { 
              ref: contentRef,
              className: 'absolute',
              style: { 
                transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                transformOrigin: '0 0',
                left: '50px', top: '50px',
                pointerEvents: 'none'
              }
            },
              // Reference Image
              refImage && showRefImage && e('div', {
                className: `absolute border-2 ${refImageLocked ? 'border-gray-400' : 'border-amber-500'} rounded shadow-lg`,
                style: { 
                  left: refImagePosition.x, top: refImagePosition.y, 
                  width: refImageSize.width, height: refImageSize.height, 
                  zIndex: 1, 
                  cursor: refImageLocked ? 'default' : 'move',
                  pointerEvents: isCropping ? 'none' : 'auto'
                },
                onMouseDown: (ev) => {
                  if (isCropping) return;
                  if (refImageLocked) {
                    ev.stopPropagation();
                    setIsPanning(true);
                    panStartRef.current = { x: ev.clientX, y: ev.clientY, panX: pan.x, panY: pan.y };
                    return;
                  }
                  ev.stopPropagation();
                  setIsDraggingImage(true);
                  imgDragStartRef.current = { x: ev.clientX, y: ev.clientY, imgX: refImagePosition.x, imgY: refImagePosition.y };
                },
                onTouchStart: (ev) => {
                  if (isCropping || ev.touches.length !== 1) return;
                  if (refImageLocked) return;
                  ev.stopPropagation();
                  setIsDraggingImage(true);
                  imgDragStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, imgX: refImagePosition.x, imgY: refImagePosition.y };
                },
                onTouchMove: (ev) => {
                  if (!isDraggingImage || refImageLocked) return;
                  const dx = (ev.touches[0].clientX - imgDragStartRef.current.x) / zoom;
                  const dy = (ev.touches[0].clientY - imgDragStartRef.current.y) / zoom;
                  setRefImagePosition({ x: imgDragStartRef.current.imgX + dx, y: imgDragStartRef.current.imgY + dy });
                },
                onTouchEnd: () => setIsDraggingImage(false)
              },
                e('img', { src: refImage, alt: 'Reference', className: 'w-full h-full object-contain pointer-events-none rounded', draggable: false }),
                !refImageLocked && !isCropping && e('div', {
                  className: 'absolute bottom-0 right-0 w-10 h-10 bg-amber-500 cursor-nwse-resize rounded-tl rounded-br flex items-center justify-center',
                  onMouseDown: (ev) => {
                    ev.stopPropagation();
                    setIsResizingImage(true);
                    imgResizeStartRef.current = { w: refImageSize.width, h: refImageSize.height, x: ev.clientX, y: ev.clientY };
                  },
                  onTouchStart: (ev) => {
                    ev.stopPropagation();
                    if (ev.touches.length === 1) {
                      setIsResizingImage(true);
                      imgResizeStartRef.current = { w: refImageSize.width, h: refImageSize.height, x: ev.touches[0].clientX, y: ev.touches[0].clientY };
                    }
                  },
                  onTouchMove: (ev) => {
                    ev.stopPropagation();
                    if (isResizingImage && ev.touches.length === 1) {
                      const dx = (ev.touches[0].clientX - imgResizeStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - imgResizeStartRef.current.y) / zoom;
                      setRefImageSize({ width: Math.max(50, imgResizeStartRef.current.w + dx), height: Math.max(50, imgResizeStartRef.current.h + dy) });
                    }
                  },
                  onTouchEnd: (ev) => {
                    ev.stopPropagation();
                    setIsResizingImage(false);
                  }
                }, e('span', { className: 'text-white text-sm' }, '⤡'))
              ),
              
              // Crop overlay
              refImage && isCropping && e('div', { 
                className: 'absolute',
                style: { 
                  left: refImagePosition.x, top: refImagePosition.y, 
                  width: refImageSize.width, height: refImageSize.height,
                  pointerEvents: 'auto', zIndex: 10 
                }
              },
                e('div', { className: 'absolute inset-0 bg-black/50', style: { borderRadius: '0.25rem' } }),
                e('div', {
                  className: 'absolute border-2 border-white cursor-move',
                  style: { 
                    left: cropBox.x, top: cropBox.y, 
                    width: cropBox.w, height: cropBox.h,
                    backgroundColor: 'transparent',
                    boxShadow: '0 0 0 9999px rgba(0,0,0,0.5)'
                  },
                  onMouseDown: (ev) => {
                    ev.stopPropagation();
                    setIsDraggingCrop(true);
                    setCropDragType('move');
                    cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } };
                  },
                  onTouchStart: (ev) => {
                    if (ev.touches.length !== 1) return;
                    ev.stopPropagation();
                    setIsDraggingCrop(true);
                    setCropDragType('move');
                    cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } };
                  },
                  onTouchMove: (ev) => {
                    if (!isDraggingCrop || cropDragType !== 'move') return;
                    const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                    const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                    const box = cropStartRef.current.box;
                    setCropBox({
                      ...box,
                      x: Math.max(0, Math.min(refImageSize.width - box.w, box.x + dx)),
                      y: Math.max(0, Math.min(refImageSize.height - box.h, box.y + dy))
                    });
                  },
                  onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                },
                  // Corner handles - bigger for touch with touch handlers
                  e('div', { 
                    className: 'crop-handle', 
                    style: { top: -12, left: -12, width: 24, height: 24, cursor: 'nwse-resize' }, 
                    onMouseDown: (ev) => { ev.stopPropagation(); setIsDraggingCrop(true); setCropDragType('nw'); cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } }; },
                    onTouchStart: (ev) => { ev.stopPropagation(); if (ev.touches.length === 1) { setIsDraggingCrop(true); setCropDragType('nw'); cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } }; } },
                    onTouchMove: (ev) => {
                      ev.stopPropagation();
                      if (!isDraggingCrop || cropDragType !== 'nw') return;
                      const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                      const box = cropStartRef.current.box;
                      const newX = Math.max(0, Math.min(box.x + box.w - 20, box.x + dx));
                      const newY = Math.max(0, Math.min(box.y + box.h - 20, box.y + dy));
                      setCropBox({ x: newX, y: newY, w: box.x + box.w - newX, h: box.y + box.h - newY });
                    },
                    onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                  }),
                  e('div', { 
                    className: 'crop-handle', 
                    style: { top: -12, right: -12, width: 24, height: 24, cursor: 'nesw-resize' }, 
                    onMouseDown: (ev) => { ev.stopPropagation(); setIsDraggingCrop(true); setCropDragType('ne'); cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } }; },
                    onTouchStart: (ev) => { ev.stopPropagation(); if (ev.touches.length === 1) { setIsDraggingCrop(true); setCropDragType('ne'); cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } }; } },
                    onTouchMove: (ev) => {
                      ev.stopPropagation();
                      if (!isDraggingCrop || cropDragType !== 'ne') return;
                      const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                      const box = cropStartRef.current.box;
                      const newW = Math.max(20, Math.min(refImageSize.width - box.x, box.w + dx));
                      const newY = Math.max(0, Math.min(box.y + box.h - 20, box.y + dy));
                      setCropBox({ x: box.x, y: newY, w: newW, h: box.y + box.h - newY });
                    },
                    onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                  }),
                  e('div', { 
                    className: 'crop-handle', 
                    style: { bottom: -12, left: -12, width: 24, height: 24, cursor: 'nesw-resize' }, 
                    onMouseDown: (ev) => { ev.stopPropagation(); setIsDraggingCrop(true); setCropDragType('sw'); cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } }; },
                    onTouchStart: (ev) => { ev.stopPropagation(); if (ev.touches.length === 1) { setIsDraggingCrop(true); setCropDragType('sw'); cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } }; } },
                    onTouchMove: (ev) => {
                      ev.stopPropagation();
                      if (!isDraggingCrop || cropDragType !== 'sw') return;
                      const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                      const box = cropStartRef.current.box;
                      const newX = Math.max(0, Math.min(box.x + box.w - 20, box.x + dx));
                      const newH = Math.max(20, Math.min(refImageSize.height - box.y, box.h + dy));
                      setCropBox({ x: newX, y: box.y, w: box.x + box.w - newX, h: newH });
                    },
                    onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                  }),
                  e('div', { 
                    className: 'crop-handle', 
                    style: { bottom: -12, right: -12, width: 24, height: 24, cursor: 'nwse-resize' }, 
                    onMouseDown: (ev) => { ev.stopPropagation(); setIsDraggingCrop(true); setCropDragType('se'); cropStartRef.current = { x: ev.clientX, y: ev.clientY, box: { ...cropBox } }; },
                    onTouchStart: (ev) => { ev.stopPropagation(); if (ev.touches.length === 1) { setIsDraggingCrop(true); setCropDragType('se'); cropStartRef.current = { x: ev.touches[0].clientX, y: ev.touches[0].clientY, box: { ...cropBox } }; } },
                    onTouchMove: (ev) => {
                      ev.stopPropagation();
                      if (!isDraggingCrop || cropDragType !== 'se') return;
                      const dx = (ev.touches[0].clientX - cropStartRef.current.x) / zoom;
                      const dy = (ev.touches[0].clientY - cropStartRef.current.y) / zoom;
                      const box = cropStartRef.current.box;
                      const newW = Math.max(20, Math.min(refImageSize.width - box.x, box.w + dx));
                      const newH = Math.max(20, Math.min(refImageSize.height - box.y, box.h + dy));
                      setCropBox({ x: box.x, y: box.y, w: newW, h: newH });
                    },
                    onTouchEnd: () => { setIsDraggingCrop(false); setCropDragType(null); }
                  })
                )
              ),

              // Grid
              grid && showCanvas && e('div', { 
                className: 'absolute', 
                style: { 
                  zIndex: isCropping ? 1.5 : 2,
                  opacity: canvasOpacity, 
                  left: gridOffset.x, top: gridOffset.y, 
                  pointerEvents: isCropping ? 'none' : 'auto'
                }
              },
                e('div', {
                  ref: gridRef,
                  className: 'inline-grid border-2 border-gray-400 rounded shadow-md',
                  style: { gridTemplateColumns: `repeat(${grid[0].length}, ${cellSize}px)`, backgroundColor: 'transparent' },
                  onMouseLeave: () => { setIsPainting(false); setShowBrushCursor(false); },
                  onMouseEnter: () => { if (brushSize > 1) setShowBrushCursor(true); },
                  onMouseMove: (ev) => { setMousePos({ x: ev.clientX, y: ev.clientY }); }
                },
                  grid.map((row, y) => row.map((colorName, x) =>
                    e('div', {
                      key: `${x}-${y}`,
                      className: 'grid-cell border border-gray-300/50',
                      style: { 
                        width: cellSize, height: cellSize, 
                        backgroundColor: PALETTE[colorName]?.hex || '#ffffff', 
                        cursor: brushSize === 1 ? 'crosshair' : 'none' 
                      },
                      onMouseDown: (ev) => { ev.stopPropagation(); setIsPainting(true); paintWithBrush(x, y); },
                      onMouseEnter: () => { if (isPainting) paintWithBrush(x, y); },
                      onContextMenu: (ev) => { ev.preventDefault(); fillRegion(x, y); }
                    })
                  ))
                )
              ),

              // Empty state
              !grid && !refImage && e('div', { 
                className: 'bg-white rounded-xl p-6 shadow-sm border border-gray-200',
                style: { pointerEvents: 'auto' }
              },
                e('div', { className: 'mx-auto mb-3 text-gray-400 w-12 h-12 flex items-center justify-center' }, e(GridIcon)),
                e('h3', { className: 'text-base font-semibold text-gray-600 mb-1 text-center' }, 'No Grid Yet'),
                e('p', { className: 'text-gray-400 text-sm text-center' }, 'Create a grid to start')
              )
            ),

            // Crop action buttons (floating) - higher on mobile to avoid nav
            isCropping && e('div', { 
              className: 'absolute left-1/2 transform -translate-x-1/2 flex gap-2 z-20',
              style: { bottom: isMobile ? 80 : 16 }
            },
              e('button', { onClick: applyCrop, className: 'px-4 py-3 bg-green-500 text-white rounded-lg flex items-center gap-2 shadow-lg text-base' }, e(CheckIcon), 'Apply'),
              e('button', { onClick: cancelCrop, className: 'px-4 py-3 bg-gray-500 text-white rounded-lg flex items-center gap-2 shadow-lg text-base' }, e(XIcon), 'Cancel')
            )
          ),

          // Desktop right sidebar
          !isMobile && e('aside', { className: 'w-52 bg-white border-l border-gray-200 p-3 overflow-y-auto shrink-0' },
            // Colors
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Colors'),
              e('div', { className: 'grid grid-cols-4 gap-1.5 mb-2' },
                PALETTE_ORDER.map(name =>
                  e('button', {
                    key: name,
                    onClick: () => setSelectedColor(name),
                    className: `aspect-square rounded-lg border-2 relative shadow-sm ${selectedColor === name ? 'border-amber-500 scale-105' : 'border-gray-300'}`,
                    style: { backgroundColor: PALETTE[name].hex }
                  },
                    usedColors[name] > 0 && e('span', { className: 'absolute -top-1 -right-1 min-w-4 h-4 bg-amber-500 rounded-full text-[9px] font-bold flex items-center justify-center text-white px-0.5' }, usedColors[name] > 99 ? '99+' : usedColors[name])
                  )
                )
              ),
              e('div', { className: 'bg-gray-100 rounded-lg p-2 flex items-center gap-2' },
                e('div', { className: 'w-8 h-8 rounded-lg border-2 border-gray-300', style: { backgroundColor: PALETTE[selectedColor].hex } }),
                e('span', { className: 'text-sm font-medium' }, selectedColor)
              )
            ),

            // Brush size
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Brush Size'),
              e('div', { className: 'flex items-center gap-2' },
                e('span', { className: 'text-xs' }, '1'),
                e('input', { type: 'range', min: 1, max: 10, value: brushSize, onChange: (ev) => setBrushSize(parseInt(ev.target.value)), className: 'flex-1' }),
                e('span', { className: 'text-xs' }, '10')
              ),
              e('p', { className: 'text-xs text-gray-400 text-center' }, `${brushSize}px`)
            ),

            // Reference Image
            e('div', { className: 'mb-4' },
              e('h2', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Reference'),
              e('input', { ref: refImageInputRef, type: 'file', accept: 'image/*', onChange: handleRefUpload, className: 'hidden' }),
              !refImage ?
                e('button', { onClick: () => refImageInputRef.current?.click(), className: 'w-full py-4 border-2 border-dashed border-gray-300 rounded-lg hover:border-amber-500 flex flex-col items-center gap-1 text-gray-400' },
                  e(UploadIcon),
                  e('span', { className: 'text-xs' }, 'Upload')
                ) :
                e('div', { className: 'space-y-2' },
                  e('img', { src: refImage, alt: 'Preview', className: 'w-full rounded-lg border border-gray-300' }),
                  e('div', { className: 'flex gap-1' },
                    e('button', { onClick: () => setShowRefImage(!showRefImage), className: 'flex-1 p-2 rounded border border-gray-300 text-gray-600' }, showRefImage ? e(EyeIcon) : e(EyeOffIcon)),
                    e('button', { onClick: () => setRefImageLocked(!refImageLocked), className: `flex-1 p-2 rounded border ${refImageLocked ? 'border-amber-300 bg-amber-50 text-amber-600' : 'border-gray-300 text-gray-600'}` }, refImageLocked ? e(LockIcon) : e(UnlockIcon)),
                    e('button', { onClick: startCropping, className: 'flex-1 p-2 rounded border border-gray-300 text-gray-600' }, e(CropIcon)),
                    e('button', { onClick: () => { setRefImage(null); setOriginalImageData(null); }, className: 'flex-1 p-2 rounded border border-gray-300 text-red-500' }, e(XIcon))
                  )
                )
            )
          ),

          // Mobile bottom sheet panels
          isMobile && activePanel && e('div', { 
            className: 'fixed inset-x-0 bg-white border-t border-gray-200 rounded-t-2xl shadow-lg z-40 max-h-[60vh] overflow-y-auto bottom-sheet',
            style: { bottom: 56 }
          },
            e('div', { className: 'sticky top-0 bg-white border-b border-gray-100 p-2 flex justify-between items-center' },
              e('span', { className: 'font-semibold text-sm text-gray-700 px-2' }, 
                activePanel === 'settings' ? 'Settings' : activePanel === 'colors' ? 'Colors & Brush' : 'Reference Image'
              ),
              e('button', { onClick: () => setActivePanel(null), className: 'p-2 text-gray-500' }, e(XIcon))
            ),
            e('div', { className: 'p-3' },
              // Settings panel
              activePanel === 'settings' && e('div', { className: 'space-y-4' },
                // Grid setup
                e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Grid Setup'),
                  e('select', { value: canvasCount, onChange: (ev) => setCanvasCount(Number(ev.target.value)), className: 'w-full px-3 py-2 bg-gray-100 border border-gray-300 rounded-lg text-sm mb-2' },
                    e('option', { value: 13 }, '13 count'),
                    e('option', { value: 15 }, '15 count')
                  ),
                  e('div', { className: 'grid grid-cols-2 gap-2 mb-2' },
                    e('input', { type: 'number', value: gridWidth, onChange: (ev) => setGridWidth(ev.target.value), placeholder: 'Width', className: 'px-3 py-2 bg-gray-100 border border-gray-300 rounded-lg text-sm', min: 0, max: maxCrosses }),
                    e('input', { type: 'number', value: gridHeight, onChange: (ev) => setGridHeight(ev.target.value), placeholder: 'Height', className: 'px-3 py-2 bg-gray-100 border border-gray-300 rounded-lg text-sm', min: 0, max: maxCrosses })
                  ),
                  e('button', { onClick: createGrid, disabled: parsedWidth < 1 || parsedHeight < 1, className: 'w-full py-3 bg-amber-500 hover:bg-amber-600 disabled:bg-gray-300 rounded-lg text-sm font-medium text-white' }, grid ? 'Reset Grid' : 'Create Grid')
                ),
                // Size adjust
                grid && e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, `Adjust Size (${grid[0].length}×${grid.length})`),
                  e('div', { className: 'grid grid-cols-4 gap-2' },
                    e('button', { onClick: addRowTop, className: 'py-3 bg-green-100 rounded-lg border border-green-300 text-green-700 text-lg' }, '+↑'),
                    e('button', { onClick: addRowBottom, className: 'py-3 bg-green-100 rounded-lg border border-green-300 text-green-700 text-lg' }, '+↓'),
                    e('button', { onClick: removeRowTop, className: 'py-3 bg-red-100 rounded-lg border border-red-300 text-red-700 text-lg' }, '-↑'),
                    e('button', { onClick: removeRowBottom, className: 'py-3 bg-red-100 rounded-lg border border-red-300 text-red-700 text-lg' }, '-↓'),
                    e('button', { onClick: addColLeft, className: 'py-3 bg-green-100 rounded-lg border border-green-300 text-green-700 text-lg' }, '+←'),
                    e('button', { onClick: addColRight, className: 'py-3 bg-green-100 rounded-lg border border-green-300 text-green-700 text-lg' }, '+→'),
                    e('button', { onClick: removeColLeft, className: 'py-3 bg-red-100 rounded-lg border border-red-300 text-red-700 text-lg' }, '-←'),
                    e('button', { onClick: removeColRight, className: 'py-3 bg-red-100 rounded-lg border border-red-300 text-red-700 text-lg' }, '-→')
                  )
                ),
                // View
                e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'View'),
                  e('div', { className: 'flex items-center gap-2 mb-2' },
                    e('button', { onClick: () => setZoom(z => Math.max(0.2, z * 0.8)), className: 'p-3 bg-gray-100 rounded-lg border border-gray-300' }, e(ZoomOutIcon)),
                    e('span', { className: 'flex-1 text-center text-sm' }, Math.round(zoom * 100) + '%'),
                    e('button', { onClick: () => setZoom(z => Math.min(4, z * 1.25)), className: 'p-3 bg-gray-100 rounded-lg border border-gray-300' }, e(ZoomInIcon)),
                    e('button', { onClick: () => { setZoom(1); setPan({ x: 0, y: 0 }); }, className: 'p-3 bg-gray-100 rounded-lg border border-gray-300' }, e(HomeIcon))
                  ),
                  e('div', null,
                    e('span', { className: 'text-xs text-gray-500' }, `Canvas Opacity: ${Math.round(canvasOpacity * 100)}%`),
                    e('input', { type: 'range', min: 0.1, max: 1, step: 0.05, value: canvasOpacity, onChange: (ev) => setCanvasOpacity(parseFloat(ev.target.value)), className: 'w-full mt-1' })
                  )
                )
              ),
              
              // Colors panel
              activePanel === 'colors' && e('div', { className: 'space-y-4' },
                e('div', { className: 'grid grid-cols-6 gap-2' },
                  PALETTE_ORDER.map(name =>
                    e('button', {
                      key: name,
                      onClick: () => setSelectedColor(name),
                      className: `aspect-square rounded-xl border-3 relative ${selectedColor === name ? 'border-amber-500 scale-105 shadow-md' : 'border-gray-300'}`,
                      style: { backgroundColor: PALETTE[name].hex, minHeight: 44 }
                    })
                  )
                ),
                e('div', { className: 'flex items-center gap-3 bg-gray-100 rounded-lg p-3' },
                  e('div', { className: 'w-12 h-12 rounded-lg border-2 border-gray-300', style: { backgroundColor: PALETTE[selectedColor].hex } }),
                  e('span', { className: 'font-medium' }, selectedColor)
                ),
                e('div', null,
                  e('h3', { className: 'text-xs font-semibold text-gray-500 uppercase mb-2' }, 'Brush Size'),
                  e('div', { className: 'flex items-center gap-3' },
                    e('span', { className: 'text-sm w-6' }, '1'),
                    e('input', { type: 'range', min: 1, max: 10, value: brushSize, onChange: (ev) => setBrushSize(parseInt(ev.target.value)), className: 'flex-1' }),
                    e('span', { className: 'text-sm w-6' }, '10')
                  ),
                  e('div', { className: 'mt-2 flex justify-center' },
                    e('div', { 
                      style: { 
                        width: Math.min(brushSize * 12, 60), 
                        height: Math.min(brushSize * 12, 60), 
                        borderRadius: '50%', 
                        backgroundColor: PALETTE[selectedColor].hex,
                        border: '2px solid #9ca3af'
                      } 
                    })
                  )
                )
              ),
              
              // Reference panel
              activePanel === 'reference' && e('div', { className: 'space-y-3' },
                e('input', { ref: refImageInputRef, type: 'file', accept: 'image/*', onChange: handleRefUpload, className: 'hidden' }),
                !refImage ?
                  e('button', { onClick: () => refImageInputRef.current?.click(), className: 'w-full py-8 border-2 border-dashed border-gray-300 rounded-xl flex flex-col items-center gap-2 text-gray-400' },
                    e(UploadIcon),
                    e('span', null, 'Upload Reference Image')
                  ) :
                  e('div', { className: 'space-y-3' },
                    e('img', { src: refImage, alt: 'Preview', className: 'w-full max-h-40 object-contain rounded-lg border border-gray-300' }),
                    e('div', { className: 'grid grid-cols-4 gap-2' },
                      e('button', { onClick: () => setShowRefImage(!showRefImage), className: `p-3 rounded-lg border ${showRefImage ? 'border-gray-300' : 'border-amber-300 bg-amber-50'}` }, showRefImage ? e(EyeIcon) : e(EyeOffIcon)),
                      e('button', { onClick: () => setRefImageLocked(!refImageLocked), className: `p-3 rounded-lg border ${refImageLocked ? 'border-amber-300 bg-amber-50' : 'border-gray-300'}` }, refImageLocked ? e(LockIcon) : e(UnlockIcon)),
                      e('button', { onClick: () => { startCropping(); setActivePanel(null); }, className: 'p-3 rounded-lg border border-gray-300' }, e(CropIcon)),
                      e('button', { onClick: () => { setRefImage(null); setOriginalImageData(null); }, className: 'p-3 rounded-lg border border-red-300 text-red-500' }, e(XIcon))
                    )
                  )
              )
            )
          )
        ),

        // Spacer for fixed mobile nav
        isMobile && e('div', { style: { height: 56, flexShrink: 0 } }),

        // Mobile bottom toolbar - fixed at bottom
        isMobile && e('nav', { 
          style: { 
            position: 'fixed', 
            bottom: 0, 
            left: 0, 
            right: 0, 
            background: 'white', 
            borderTop: '1px solid #e5e7eb', 
            display: 'flex', 
            zIndex: 50, 
            minHeight: 56 
          }
        },
          e(TabButton, { icon: e(SettingsIcon), label: 'Settings', active: activePanel === 'settings', onClick: () => setActivePanel(activePanel === 'settings' ? null : 'settings') }),
          e(TabButton, { icon: e(PaletteIcon), label: 'Colors', active: activePanel === 'colors', onClick: () => setActivePanel(activePanel === 'colors' ? null : 'colors') }),
          e(TabButton, { icon: e(ImageIcon), label: 'Reference', active: activePanel === 'reference', onClick: () => setActivePanel(activePanel === 'reference' ? null : 'reference') }),
          e('button', { 
            onClick: () => setShowCanvas(!showCanvas), 
            className: `flex-1 flex flex-col items-center justify-center py-2 px-1 ${!showCanvas ? 'text-amber-500 bg-amber-50' : 'text-gray-600'}` 
          },
            showCanvas ? e(EyeIcon) : e(EyeOffIcon),
            e('span', { className: 'text-[10px] mt-0.5' }, showCanvas ? 'Hide' : 'Show')
          )
        ),

        // Brush cursor (desktop only)
        !isMobile && showBrushCursor && brushSize > 1 && e('div', {
          style: {
            position: 'fixed',
            left: mousePos.x, top: mousePos.y,
            width: brushSize * cellSize * zoom,
            height: brushSize * cellSize * zoom,
            border: '2px solid ' + PALETTE[selectedColor].hex,
            borderRadius: '50%',
            pointerEvents: 'none',
            transform: 'translate(-50%, -50%)',
            zIndex: 1000,
            boxShadow: '0 0 0 1px rgba(255,255,255,0.8), inset 0 0 0 1px rgba(255,255,255,0.8)'
          }
        })
      );
    }

    ReactDOM.render(React.createElement(App), document.getElementById('root'));
  </script>
</body>
</html>
